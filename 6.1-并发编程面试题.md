## è¯·æè¿°ä¸€ä¸‹å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹ - ç¾å›¢ é¡ºä¸°

### ç±»çš„ç”Ÿå‘½å‘¨æœŸ

è§£æï¼šå›ç­”è¿™ä¸ªé—®é¢˜é¦–å…ˆå°±è¦æ¸…æ¥šç±»çš„ç”Ÿå‘½å‘¨æœŸ

ä¸‹å›¾å±•ç¤ºçš„æ˜¯ç±»çš„ç”Ÿå‘½å‘¨æœŸæµå‘ï¼šã€€ã€€ã€€
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201215104106343.png)

Javaä¸­å¯¹è±¡çš„åˆ›å»ºå°±æ˜¯åœ¨å †ä¸Šåˆ†é…å†…å­˜ç©ºé—´çš„è¿‡ç¨‹ï¼Œæ­¤å¤„è¯´çš„å¯¹è±¡åˆ›å»ºä»…é™äºnewå…³é”®å­—åˆ›å»ºçš„æ™®é€šJavaå¯¹è±¡ï¼Œä¸åŒ…æ‹¬æ•°ç»„å¯¹è±¡çš„åˆ›å»ºã€‚

### å¯¹è±¡åˆ›å»ºè¿‡ç¨‹

1. æ£€æµ‹ç±»æ˜¯å¦è¢«åŠ è½½ï¼š
   ã€€ã€€å½“è™šæ‹Ÿæœºæ‰§è¡Œåˆ°newæ—¶ï¼Œä¼šå…ˆå»å¸¸é‡æ± ä¸­æŸ¥æ‰¾è¿™ä¸ªç±»çš„ç¬¦å·å¼•ç”¨ã€‚å¦‚æœèƒ½æ‰¾åˆ°ç¬¦å·å¼•ç”¨ï¼Œè¯´æ˜æ­¤ç±»å·²ç»è¢«åŠ è½½åˆ°æ–¹æ³•åŒºï¼ˆæ–¹æ³•åŒºå­˜å‚¨è™šæ‹Ÿæœºå·²ç»åŠ è½½çš„ç±»çš„ä¿¡æ¯ï¼‰ï¼Œå¯ä»¥ç»§ç»­æ‰§è¡Œï¼›å¦‚æœæ‰¾ä¸åˆ°ç¬¦å·å¼•ç”¨ï¼Œå°±ä¼šä½¿ç”¨ç±»åŠ è½½å™¨æ‰§è¡Œç±»çš„åŠ è½½è¿‡ç¨‹ï¼Œç±»åŠ è½½å®Œæˆåç»§ç»­æ‰§è¡Œã€‚
2. ä¸ºå¯¹è±¡åˆ†é…å†…å­˜ï¼š
   ã€€ã€€ç±»åŠ è½½å®Œæˆä»¥åï¼Œè™šæ‹Ÿæœºå°±å¼€å§‹ä¸ºå¯¹è±¡åˆ†é…å†…å­˜ï¼Œæ­¤æ—¶æ‰€éœ€å†…å­˜çš„å¤§å°å°±å·²ç»ç¡®å®šäº†ã€‚åªéœ€è¦åœ¨å †ä¸Šåˆ†é…æ‰€éœ€è¦çš„å†…å­˜å³å¯ã€‚
3. ä¸ºåˆ†é…çš„å†…å­˜ç©ºé—´åˆå§‹åŒ–é›¶å€¼ï¼š
   ã€€ã€€å¯¹è±¡çš„å†…å­˜åˆ†é…å®Œæˆåï¼Œè¿˜éœ€è¦å°†å¯¹è±¡çš„å†…å­˜ç©ºé—´éƒ½åˆå§‹åŒ–ä¸ºé›¶å€¼ï¼Œè¿™æ ·èƒ½ä¿è¯å¯¹è±¡å³ä½¿æ²¡æœ‰èµ‹åˆå€¼ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨
4. å¯¹å¯¹è±¡è¿›è¡Œå…¶ä»–è®¾ç½®ï¼š
   ã€€ã€€åˆ†é…å®Œå†…å­˜ç©ºé—´ï¼Œåˆå§‹åŒ–é›¶å€¼ä¹‹åï¼Œè™šæ‹Ÿæœºè¿˜éœ€è¦å¯¹å¯¹è±¡è¿›è¡Œå…¶ä»–å¿…è¦çš„è®¾ç½®ï¼Œè®¾ç½®çš„åœ°æ–¹éƒ½åœ¨å¯¹è±¡å¤´ä¸­ï¼ŒåŒ…æ‹¬è¿™ä¸ªå¯¹è±¡æ‰€å±çš„ç±»ï¼Œç±»çš„å…ƒæ•°æ®ä¿¡æ¯ï¼Œå¯¹è±¡çš„hashcodeï¼ŒGCåˆ†ä»£å¹´é¾„ç­‰ä¿¡æ¯ã€‚
5. æ‰§è¡Œ init æ–¹æ³•ï¼š
   ã€€ã€€æ‰§è¡Œå®Œä¸Šé¢çš„æ­¥éª¤ä¹‹åï¼Œåœ¨è™šæ‹Ÿæœºé‡Œè¿™ä¸ªå¯¹è±¡å°±ç®—åˆ›å»ºæˆåŠŸäº†ï¼Œä½†æ˜¯å¯¹äºJavaç¨‹åºæ¥è¯´è¿˜éœ€è¦æ‰§è¡Œinitæ–¹æ³•æ‰ç®—çœŸæ­£çš„åˆ›å»ºå®Œæˆï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™å¯¹è±¡åªæ˜¯è¢«åˆå§‹åŒ–é›¶å€¼äº†ï¼Œè¿˜æ²¡æœ‰çœŸæ­£çš„å»æ ¹æ®ç¨‹åºä¸­çš„ä»£ç åˆ†é…åˆå§‹å€¼ï¼Œè°ƒç”¨äº†initæ–¹æ³•ä¹‹åï¼Œè¿™ä¸ªå¯¹è±¡æ‰çœŸæ­£èƒ½ä½¿ç”¨ã€‚

> åˆ°æ­¤ä¸ºæ­¢ä¸€ä¸ªå¯¹è±¡å°±äº§ç”Ÿäº†ï¼Œè¿™å°±æ˜¯newå…³é”®å­—åˆ›å»ºå¯¹è±¡çš„è¿‡ç¨‹ã€‚è¿‡ç¨‹å¦‚ä¸‹

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201215102813871.png)



## å¯¹è±¡åœ¨å†…å­˜ä¸­çš„å†…å­˜å¸ƒå±€- ç¾å›¢ é¡ºä¸°

**å¯¹è±¡å†…å­˜å¸ƒå±€**

ä¸€ä¸ªJavaå¯¹è±¡åœ¨å†…å­˜ä¸­åŒ…æ‹¬å¯¹è±¡å¤´ã€å®ä¾‹æ•°æ®å’Œå¯¹é½å¡«å……ä¸‰ä¸ªéƒ¨åˆ†ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![å›¾ 15-1 64ä½JVMå¯¹è±¡ç»“æ„æè¿°](img/20201029102121624.png)

**Mark Word**
åŒ…å«ä¸€ç³»åˆ—çš„æ ‡è®°ä½æ¯”å¦‚hashcodeã€GCåˆ†ä»£å¹´é¾„ã€åå‘é”ä½ï¼Œé”æ ‡å¿—ä½ç­‰ã€‚è¿™ä¸ªMark Wordåœ¨å¯¹è±¡è¢«åŠ äº†ä¸åŒé‡çº§çš„é”æ—¶æ‰€åŒ…å«çš„å†…å®¹å’Œå¸ƒå±€éƒ½æœ‰æ‰€ä¸åŒï¼Œè¿™æ¶‰åŠåˆ°é”å‡çº§çš„çŸ¥è¯†ï¼Œæš‚ä¸å±•å¼€è®¨è®º

**Klass Pointer**
æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘æè¿°è¿™ä¸ªå¯¹è±¡ç±»å‹çš„å…ƒå¯¹è±¡ï¼Œä¾‹å¦‚Object.classï¼ŒUser.classç­‰

**å®ä¾‹æ•°æ®**
instance dataï¼šæè¿°æˆå‘˜å˜é‡çš„ä¿¡æ¯ï¼Œå¦‚æœæˆå‘˜å˜é‡æ˜¯å¼•ç”¨ç±»å‹ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚instance dataçš„å¤§å°æ˜¯æ‰€æœ‰æˆå‘˜å˜é‡çš„å ç”¨ç©ºé—´ï¼ˆåŸºæœ¬æ•°æ®ç±»å‹å¤§å°+æŒ‡é’ˆå¤§å°ï¼‰

**å¯¹é½**
padding dataï¼šåœ¨javaä¸­ï¼Œä¸ºäº†èƒ½å¤Ÿæ›´åŠ é«˜æ•ˆçš„åˆ©ç”¨å†…å­˜ç©ºé—´ï¼Œä¼šå°†å¯¹è±¡å¤§å°è®¾å®šä¸º8bytesçš„æ•´æ•°å€ï¼Œå¦‚æœå¯¹è±¡å¤´+å®ä¾‹æ•°æ®çš„å¤§å°ä¸æ˜¯8bytesçš„å€æ•°ï¼Œé‚£ä¹ˆä¼šåœ¨paddingåŒºåŸŸå¡«å……å‡ ä¸ªå­—èŠ‚ï¼Œä½¿å¾—å¯¹è±¡å ç”¨ç©ºé—´æ˜¯8bytesçš„å€æ•°



## Object o = new Object()åœ¨å†…å­˜ä¸­å äº†å¤šå°‘å­—èŠ‚? - é¡ºä¸°

é‚£ä¹ˆå¯¹è±¡å¸ƒå±€ä¸­å„ä¸ªéƒ¨åˆ†å ç”¨å†…å­˜ç©ºé—´åˆ°åº•å¤šå¤§å‘¢ï¼Ÿç”±äºç›®å‰64ä½æ“ä½œç³»ç»Ÿå·²ç»åŸºæœ¬æ™®åŠï¼Œä¸‹é¢åªåˆ†æ64ä½æ“ä½œç³»ç»Ÿä¸‹çš„æƒ…å†µ

**æŒ‡é’ˆå‹ç¼©**
åœ¨64ä½ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªæŒ‡é’ˆå 64 bitsä¹Ÿå°±æ˜¯8 bytesï¼Œè€Œåœ¨32ä½ç³»ç»Ÿä¸­æŒ‡é’ˆåªå 4ä¸ªå­—èŠ‚ï¼Œäºæ˜¯ä¸ºäº†èƒ½å¤Ÿå‡å°‘å†…å­˜æ¶ˆè€—ï¼Œä»JDK1.6å¼€å§‹ï¼ŒJVMä¼šé»˜è®¤æ”¯æŒæŒ‡é’ˆå‹ç¼©ï¼Œä¼šå°†æŒ‡é’ˆå¤§å°å‹ç¼©æˆ4ä¸ªå­—èŠ‚ï¼Œè¿™æ¶‰åŠåˆ°ä¸¤ä¸ªå‚æ•°ï¼š

- **-XX:+UseCompressedOops**ï¼šoops: ordinary object pointerï¼Œæ™®é€šå¯¹è±¡æŒ‡é’ˆå‹ç¼©ï¼Œä¾‹å¦‚Object o = new Object();å…¶ä¸­oå°±æ˜¯ä¸ªæŒ‡å‘new Object()å¯¹è±¡çš„æŒ‡é’ˆï¼Œoåœ¨æŒ‡é’ˆå‹ç¼©å‰å ç”¨8ä¸ªå­—èŠ‚ï¼Œåœ¨æŒ‡é’ˆå‹ç¼©åå ç”¨4ä¸ªå­—èŠ‚
- **-XX:+UseCompressedClassPointers**ï¼šå‹ç¼©Klass Pointerï¼Œå‹ç¼©å‰8ä¸ªå­—èŠ‚ï¼Œå‹ç¼©å4ä¸ªå­—èŠ‚

> Hotspotå®ç°çš„JVMå¼€å¯å†…å­˜å‹ç¼©çš„è§„åˆ™ï¼ˆ64ä½æœºå™¨ï¼‰ï¼š
>
> - 4Gä»¥ä¸‹ï¼Œç›´æ¥ç æ‰é«˜32ä½
> - 4G~32Gï¼Œé»˜è®¤å¼€å¯å†…å­˜å‹ç¼©
> - 32Gä»¥ä¸Šï¼Œå‹ç¼©æ— æ•ˆï¼Œä½¿ç”¨64ä½
>
> æ‰€ä»¥ï¼Œå†…å­˜å¹¶ä¸æ˜¯è¶Šå¤§è¶Šå¥½ã€‚

![img](img/v2-ed71990d587702c6935598ccbc4af164_720w.jpg)

**æ™®é€šå¯¹è±¡å†…å­˜å„éƒ¨åˆ†å­—èŠ‚å ç”¨åˆ†é…æƒ…å†µï¼š**

1ã€`Mark Word`ï¼š8byte
2ã€`Klass Pointer`ï¼š

- -XX:+UseCompressedClassPointerçš„æƒ…å†µä¸º 4byte
- -XX:-UseCompressedClassPointerçš„æƒ…å†µä¸º 8byte

3ã€`å®ä¾‹æ•°æ®instance data`ï¼š

å¦‚æœæˆå‘˜å˜é‡æ˜¯å¼•ç”¨ç±»å‹ï¼Œå­—èŠ‚å ç”¨æƒ…å†µï¼š

- -XX:+UseCompressedOops 4byte
- -XX:-UseCompressedOops 8byte

å¦‚æœæˆå‘˜å˜é‡æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼Œé‚£ä¹ˆå ç”¨ç©ºé—´å°±æ˜¯åŸºæœ¬æ•°æ®ç±»å‹çš„å¤§å°ï¼ŒJavaçš„8å¤§åŸºæœ¬æ•°æ®ç±»å‹çš„å¤§å°å¦‚ä¸‹ï¼š

| æ•°æ®ç±»å‹ | å ç”¨ç©ºé—´bytes |
| :------: | :-----------: |
|   byte   |       1       |
|  short   |       2       |
|   int    |       4       |
|   long   |       8       |
|  float   |       4       |
|  double  |       8       |
|   char   |       2       |
| boolean  |       1       |

4ã€`å¯¹é½padding`ï¼šå¦‚æœå¯¹è±¡å¤´+å®ä¾‹æ•°æ®çš„å¤§å°ä¸æ˜¯8 bytesçš„å€æ•°ï¼Œé‚£ä¹ˆå°±å¡«å……è¿™ä¸ªåŒºåŸŸï¼Œä½¿å¾—å¯¹è±¡å ç”¨ç©ºé—´èƒ½è¢«8ä¸ªå­—èŠ‚æ•´é™¤

**æ•°ç»„å¯¹è±¡å†…å­˜å„éƒ¨åˆ†å­—èŠ‚å ç”¨åˆ†é…æƒ…å†µï¼š**

1ã€`markword` 8å­—èŠ‚
2ã€`Klass Pointer`æŒ‡é’ˆï¼ŒåŒæ™®é€šå¯¹è±¡ï¼Œå‹ç¼©4å­—èŠ‚ï¼Œä¸å‹ç¼©8å­—èŠ‚
3ã€æ•°ç»„é•¿åº¦ 4å­—èŠ‚
4ã€æ•°ç»„æ•°æ®
5ã€å¯¹é½8çš„å€æ•°

**è®¡ç®—new Object()å ç”¨çš„å­—èŠ‚æ•°**

- é¦–å…ˆï¼Œ`markword`å `8å­—èŠ‚`
- `KlassPointer`ï¼šæˆ‘çš„æœºå™¨å†…å­˜æ˜¯8Gï¼ŒJVMé»˜è®¤æ˜¯å¼€å¯äº†å†…å­˜å‹ç¼©è§„åˆ™çš„ï¼Œæ‰€ä»¥è¿™é‡ŒClassPointerä¼šå ç”¨`4å­—èŠ‚`
- å®ä¾‹æ•°æ®ï¼šæˆ‘åªæ˜¯newäº†ä¸€ä¸ªObject()ï¼Œæ²¡æœ‰ä»»ä½•çš„å¼•ç”¨ç±»å‹å’Œè´¹ç”¨ç”¨ç±»å‹ï¼Œè¿™éƒ¨åˆ†æ²¡æœ‰å ç”¨å­—èŠ‚
- `Padding`å¯¹é½ï¼šå‰é¢8+4+0=12å­—èŠ‚ï¼Œå› ä¸ºè¦æ»¡è¶³8çš„å€æ•°ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦`è¡¥é½`è‡³`16å­—èŠ‚`

æ‰€ä»¥ï¼Œ`new Object()`å ç”¨16å­—èŠ‚ã€‚

**è®¡ç®—new int[]{}å ç”¨çš„å­—èŠ‚æ•°**

- `markword`: 8å­—èŠ‚
- `ClassPointer`ï¼š4å­—èŠ‚
- `æ•°ç»„é•¿åº¦`ï¼š4å­—èŠ‚
- `æ•°ç»„æ•°æ®`ï¼š0å­—èŠ‚
- `Padding`å¯¹é½ï¼šå‰é¢8+4+4+0=16ï¼Œå·²ç»æ˜¯8çš„å€æ•°äº†ï¼Œè¿™é‡Œä¸éœ€è¦å¯¹é½

å› æ­¤ï¼Œ`new int[]{}`å ç”¨16å­—èŠ‚ã€‚

**è®¡ç®—è‡ªå®šä¹‰çš„`new P()`å ç”¨çš„å­—èŠ‚æ•°**

```java
private static class P {
    // markword 8
    // ClassPinter 4 (+UseCompressedClassPointeræ—¶ ä¸º4ï¼›-UseCompressedClassPointeræ—¶ ä¸º8)
    
    // 4
    int id;
    // Oops 4
    String name;// è¿™æ˜¯ä¸€ä¸ªå¼•ç”¨ +UseCompressedOopsæ—¶ ä¸º8  -UseCompressedOopsæ—¶ ä¸º4
    // Oops 4
    private int[] ages;
    // 1
    byte b1;
    // 1
    byte b2;
    //Oops 4
    Object o;
    // 8
    long i;
}
```

![image-20210125112156239](img/image-20210125112156239.png)

**è¯æ˜å¯¹è±¡å†…å­˜å¸ƒå±€**

æˆ‘ä»¬éœ€è¦å¼•ç”¨ä¸€ä¸ªä¾èµ–ï¼šopenjdkæä¾›çš„jol-coreï¼š

```xml
<dependency>
	<groupId>org.openjdk.jol</groupId>
	<artifactId>jol-core</artifactId>
	<version>0.9</version>
</dependency>
```

1ã€æŸ¥çœ‹é»˜è®¤æƒ…å†µä¸‹æ²¡æœ‰æˆå‘˜å˜é‡çš„å¯¹è±¡å¸ƒå±€

ç¤ºä¾‹ä»£ç ï¼š

```java
public class TestObj {
    public static void main(String[] args) {
        // åˆ›å»ºå¯¹è±¡
        Object o = new Object();
        // è·å¾—å¯¹è±¡å¸ƒå±€å†…å®¹
        String s = ClassLayout.parseInstance(o).toPrintable();
        // æ‰“å°å¯¹è±¡å¸ƒå±€
        System.out.println(s);
    }
}
```

è¾“å‡ºç»“æœï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201104211211793.png)

å…¶ä¸­å¯¹è±¡å¤´ï¼ˆobject headerï¼‰æœ‰ä¸‰ä¸ªï¼Œå‰ä¸¤ä¸ªæ˜¯Mark Wordä¸€å…±8ä¸ªå­—èŠ‚ï¼Œåé¢ä¸€ä¸ªæ˜¯Klass Pointerï¼Œå 4ä¸ªå­—èŠ‚ï¼Œç”±äºæ²¡æœ‰æˆå‘˜å˜é‡ï¼Œæ‰€ä»¥å®ä¾‹æ•°æ®æ²¡æœ‰å ç”¨ç©ºé—´ï¼Œè€Œæœ€å4ä¸ªå­—èŠ‚æè¿°ä¿¡æ¯ä¸ºï¼šloss due to the next object alignmentï¼Œæ„æ€å°±æ˜¯ä¸ºäº†ä¸ä¸‹ä¸€ä¸ªå¯¹è±¡å¯¹é½è€Œä¸¢å¤±çš„éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯å¯¹é½å¡«å……ç©ºé—´

2ã€è¯æ˜Klass Pointeråœ¨ä¸å¼€å¯å‹ç¼©çš„æƒ…å†µä¸‹å ç”¨8ä¸ªå­—èŠ‚

æˆ‘ä»¬åªéœ€è¦åœ¨jvmå‚æ•°ä¸ŠåŠ ä¸Š-XX:-UseCompressedClassPointerså³å¯ï¼Œåœ¨IDEAå·¥å…·ä¸­å¯ä»¥è®¾ç½®å¯åŠ¨å‚æ•°ï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201104211922499.png)

è¿˜æ˜¯è¿è¡Œä¸Šè¿°ä»£ç ï¼Œè¿è¡Œç¨‹åºç»“æœï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201104211959527.png)

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå¯¹è±¡å¤´å·²ç»å ç”¨16ä¸ªå­—èŠ‚ï¼Œå‰8ä¸ªå­—èŠ‚æ˜¯Mark Wordï¼Œå8ä¸ªå­—èŠ‚å°±æ˜¯æœªå‹ç¼©çš„Klass Pointerã€‚æˆ‘ä»¬è¿˜æ³¨æ„åˆ°å¯¹é½å¡«å……ä¹Ÿæ²¡æœ‰äº†ï¼ŒåŸå› æ˜¯æ­¤æ—¶å¯¹è±¡å ç”¨ç©ºé—´16ä¸ªå­—èŠ‚å·²ç»æ˜¯8bytesçš„å€æ•°ï¼Œæ‰€ä»¥ä¸éœ€è¦å¡«å……ï¼Œè¿™å®Œå…¨å°è¯äº†å‰é¢çš„åˆ†æ

3ã€è¯æ˜å®ä¾‹æ•°æ®çš„å­˜åœ¨ä»¥åŠå¤§å°

ç¤ºä¾‹ä»£ç ï¼š

```java
public class TestObj {
    public static void main(String[] args) {
        // åˆ›å»ºå¯¹è±¡
        User user = new User(1, "zhangsan");
        // è·å¾—å¯¹è±¡å¸ƒå±€å†…å®¹
        String s = ClassLayout.parseInstance(user).toPrintable();
        // æ‰“å°å¯¹è±¡å¸ƒå±€
        System.out.println(s);
    }
}

class User {
    private int id;
    private String name;

    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
```

æ‰“å°ç»“æœï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201104212637338.png)

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œintç±»å‹çš„idå ç”¨4ä¸ªå­—èŠ‚ï¼ŒæŒ‡å‘å­—ç¬¦ä¸²å¯¹è±¡çš„nameæŒ‡é’ˆå ç”¨4ä¸ªå­—èŠ‚ï¼ŒåŠ ä¸Šå¯¹é½ï¼Œå¯¹è±¡ä¸€å…±å ç”¨24 bytes

4ã€æœ€åéªŒè¯ä¸å¼€å¯æŒ‡é’ˆå‹ç¼©çš„æƒ…å†µä¸‹æŒ‡é’ˆå ç”¨8 bytes

åªéœ€åœ¨jvmå‚æ•°ä¸ŠåŠ ä¸Š-XX:-UseCompressedOopsï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201104212951634.png)

è¿˜æ˜¯è¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œæ‰“å°ç»“æœï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201104213058608.png)

å¾ˆæ˜¾ç„¶ï¼Œæ­¤æ—¶nameæŒ‡é’ˆå·²ç»å ç”¨äº†8ä¸ªå­—èŠ‚

ä¸€èˆ¬æ¥è¯´ï¼ŒUseCompressedClassPointerså’ŒUseCompressedOopsæ˜¯é»˜è®¤å¼€å¯çš„ï¼Œæˆ‘ä»¬æ— éœ€å…³å¿ƒä¹Ÿæ— éœ€ä¿®æ”¹ã€‚ä½†æ˜¯æœ‰ä¸ªéšè—çš„ç»†èŠ‚å°±æ˜¯ï¼šUseCompressedClassPointersçš„å¼€å¯ä¾èµ–UseCompressedOopsçš„å¼€å¯ï¼Œå¹¶ä¸”å¼€å¯UseCompressedOops ä¹Ÿé»˜è®¤å¼ºåˆ¶å¼€å¯UseCompressedClassPointersï¼Œå…³é—­UseCompressedOops é»˜è®¤å…³é—­UseCompressedClassPointersã€‚



## è¯·æè¿°é”çš„å››ç§çŠ¶æ€å’Œå‡çº§è¿‡ç¨‹ - ç™¾åº¦ é˜¿é‡Œ

åœ¨Javaï¼ˆ1.6+ï¼‰ä¸­é”çš„çŠ¶æ€ä¸€å…±æœ‰å››ç§ï¼Œçº§åˆ«ç”±ä½åˆ°é«˜åˆ†åˆ«æ˜¯ï¼šæ— é”ã€åå‘é”ã€è½»é‡çº§é”ã€é‡é‡çº§é”ï¼Œè¿™å‡ ä¸ªçŠ¶æ€ä¼šéšç€ç«äº‰æƒ…å†µé€æ¸å‡çº§ï¼Œå…¶ä¸­é”å¯ä»¥å‡çº§ï¼Œä½†æ˜¯ä¸èƒ½é™çº§ã€‚Javaä¸­åŠ é”çš„æœ€ç®€å•æ–¹å¼å°±æ˜¯åŠ synchronizedå…³é”®å­—ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆé”ä¼šæœ‰è¿™ä¹ˆå¤šçŠ¶æ€çš„é”å‘¢ï¼Ÿ

åœ¨Javaæ—©æœŸï¼Œsynchronizedå«åšé‡é‡çº§é”ï¼ŒåŠ é”è¿‡ç¨‹éœ€è¦æ“ä½œç³»ç»Ÿåœ¨å†…æ ¸æ€è®¿é—®æ ¸å¿ƒèµ„æºï¼Œå› æ­¤æ“ä½œç³»ç»Ÿä¼šåœ¨ç”¨æˆ·æ€ä¸å†…æ ¸æ€ä¹‹é—´åˆ‡æ¢ï¼Œæ•ˆç‡å¾ˆä½ä¸‹ã€‚äºæ˜¯JDK1.6ä¹‹åï¼ŒJVMä¸ºäº†æé«˜é”çš„è·å–ä¸é‡Šæ”¾æ•ˆç‡ï¼Œå¯¹synchronizedè¿›è¡Œäº†ä¼˜åŒ–ï¼Œå¼•å…¥äº†åå‘é”å’Œè½»é‡çº§é”ï¼Œæ ¹æ®çº¿ç¨‹ç«äº‰æƒ…å†µå¯¹é”è¿›è¡Œå‡çº§ï¼Œåœ¨çº¿ç¨‹ç«äº‰ä¸æ¿€çƒˆçš„æƒ…å†µé¿å…ä½¿ç”¨é‡é‡çº§é”ã€‚

åœ¨äº†è§£é”ä¹‹å‰éœ€è¦å…ˆäº†è§£ä¸€ä¸‹**å¯¹è±¡å¤´**ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“åœ¨Javaä¸­é”ä¸æ˜¯æŸä¸€ä¸ªå…·ä½“çš„å®ç‰©èµ„æºï¼Œè€Œæ˜¯å¯¹è±¡ä¸Šçš„æŸä¸ªæ ‡è®°ï¼Œè€Œè¿™ä¸ªæ ‡è®°å°±è®°å½•åœ¨å¯¹è±¡å¤´ï¼ˆMark Wordï¼‰ä¸Šã€‚Mark Wordï¼ˆå¯¹è±¡å¤´ï¼‰æ˜¯Javaå¯¹è±¡å¸ƒå±€ä¸­çš„ä¸€ä¸ªéƒ¨åˆ†ï¼Œé‚£ä¹ˆMark Wordå†…éƒ¨æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼Ÿ

åœ¨32ä½è™šæ‹Ÿæœºä¸­ï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201111213805505.png)

åœ¨64ä½è™šæ‹Ÿæœºä¸­ï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201111213836376.png)

ç”±äºç°åœ¨è®¡ç®—æœºåŸºæœ¬éƒ½æ˜¯64ä½ï¼Œæ‰€ä»¥ä¸‹é¢ä»¥64ä½è™šæ‹Ÿæœºä¸ºä¾‹ï¼Œçœ‹ä¸€ä¸‹é”å…·ä½“æ˜¯å¦‚ä½•å‡çº§çš„
**æ— é”**ï¼šå¯¹è±¡å¤´ä¸­æœ‰31bitçš„ç©ºé—´æ¥å­˜å‚¨å¯¹è±¡çš„hashcodeï¼Œ4bitç”¨äºå­˜æ”¾å¯¹è±¡åˆ†ä»£å¹´é¾„ï¼Œ1bitæ¥è¡¨ç¤ºæ˜¯å¦æ˜¯åå‘é”ï¼Œ2bitå­˜æ”¾é”æ ‡å¿—ä½ï¼Œåå‘é”ä½ä¸é”æ ‡å¿—ä½åˆèµ·æ¥â€œ001â€å°±ä»£è¡¨æ— é”ã€‚æ— é”å°±æ˜¯æ²¡æœ‰å¯¹ä»»ä½•èµ„æºè¿›è¡Œé”å®šï¼Œæ‰€æœ‰çº¿ç¨‹éƒ½èƒ½è®¿é—®å¹¶ä¿®æ”¹èµ„æºã€‚
**åå‘é”**ï¼šå¯¹è±¡å¤´ä¸­è®°å½•äº†è·å¾—åå‘é”çš„çº¿ç¨‹IDï¼Œåå‘é”ä¸é”æ ‡å¿—ä½åˆèµ·æ¥â€œ101â€å°±ä»£è¡¨åå‘é”ã€‚æœ‰ç ”ç©¶å‘ç°ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œé”å¾ˆå°‘è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ç«äº‰ï¼Œè€Œä¸”æ€»æ˜¯ç”±åŒä¸€ä¸ªçº¿ç¨‹å¤šæ¬¡è·å¾—ï¼Œå› æ­¤åªéœ€è¦å°†è·å¾—é”çš„çº¿ç¨‹IDå†™å…¥åˆ°é”å¯¹è±¡Mark Wordä¸­ï¼Œç›¸å½“äºå‘Šè¯‰å…¶ä»–çº¿ç¨‹ï¼Œè¿™å—èµ„æºå·²ç»è¢«æˆ‘å äº†ã€‚å½“çº¿ç¨‹è®¿é—®èµ„æºç»“æŸåï¼Œä¸ä¼šä¸»åŠ¨é‡Šæ”¾åå‘é”ï¼Œå½“çº¿ç¨‹å†æ¬¡éœ€è¦è®¿é—®èµ„æºæ—¶ï¼ŒJVMå°±ä¼šé€šè¿‡Mark Wordä¸­è®°å½•çš„çº¿ç¨‹IDåˆ¤æ–­æ˜¯å¦æ˜¯å½“å‰çº¿ç¨‹ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ç»§ç»­è®¿é—®èµ„æºã€‚æ‰€ä»¥ï¼Œåœ¨æ²¡æœ‰å…¶ä»–çº¿ç¨‹å‚ä¸ç«äº‰æ—¶ï¼Œé”å°±ä¸€ç›´åå‘è¢«å½“å‰çº¿ç¨‹æŒæœ‰ï¼Œå½“å‰çº¿ç¨‹å°±å¯ä»¥ä¸€ç›´å ç”¨èµ„æºæˆ–è€…æ‰§è¡Œä»£ç ã€‚
**è½»é‡çº§é”**ï¼šä¸€æ—¦æœ‰å¦å¤–ä¸€ä¸ªçº¿ç¨‹å‚ä¸é”ç«äº‰ï¼Œåå‘é”å°±ä¼šå‡çº§ä¸ºè½»é‡çº§é”ï¼Œæ­¤æ—¶æ’¤é”€åå‘é”ï¼Œé”æ ‡å¿—ä½å˜ä¸ºâ€œ00â€ã€‚ç«äº‰çš„ä¸¤ä¸ªçº¿ç¨‹éƒ½åœ¨å„è‡ªçš„çº¿ç¨‹æ ˆå¸§ä¸­ç”Ÿæˆä¸€ä¸ªLock Recordç©ºé—´ï¼Œç”¨äºå­˜å‚¨é”å¯¹è±¡ç›®å‰Mark Wordçš„æ‹·è´ï¼Œç”¨CASæ“ä½œå°†Mark Wordè®¾ç½®ä¸ºæŒ‡å‘è‡ªå·±è¿™ä¸ªçº¿ç¨‹çš„LRï¼ˆLock Recordï¼‰æŒ‡é’ˆï¼Œè®¾ç½®æˆåŠŸè€…è·å¾—é”ï¼Œå…¶ä»–å‚ä¸ç«äº‰çš„çº¿ç¨‹å¦‚æœæœªè·å–åˆ°é”ï¼Œåˆ™ä¼šä¸€ç›´å¤„äºè‡ªæ—‹ç­‰å¾…çš„çŠ¶æ€ï¼Œç›´åˆ°ç«äº‰åˆ°é”ã€‚
**é‡é‡çº§é”**ï¼šé•¿æ—¶é—´çš„è‡ªæ—‹æ“ä½œæ˜¯å¾ˆæ¶ˆè€—CPUèµ„æºçš„ï¼Œä¸ºäº†é¿å…è¿™ç§ç›²ç›®çš„æ¶ˆè€—ï¼ŒJVMä¼šåœ¨æœ‰çº¿ç¨‹è¶…è¿‡10æ¬¡è‡ªæ—‹ï¼Œæˆ–è€…è‡ªæ—‹æ¬¡æ•°è¶…è¿‡CPUæ ¸æ•°çš„ä¸€åŠï¼ˆJDK1.6ä»¥ååŠ å…¥äº†è‡ªé€‚åº”è‡ªæ—‹-Adaptive Self Spinningï¼Œç”±JVMè‡ªå·±æ§åˆ¶è‡ªæ—‹æ¬¡æ•°ï¼‰æ—¶ï¼Œä¼šå‡çº§åˆ°é‡é‡çº§é”ã€‚é‡é‡çº§é”åº•å±‚æ˜¯ä¾èµ–æ“ä½œç³»ç»Ÿçš„mutexäº’æ–¥é”ï¼Œä¹Ÿå°±æ˜¯æœ‰æ“ä½œç³»ç»Ÿæ¥è´Ÿè´£çº¿ç¨‹é—´çš„è°ƒåº¦ã€‚é‡é‡çº§é”å‡å°‘äº†è‡ªæ—‹é”å¸¦æ¥çš„CPUæ¶ˆè€—ï¼Œä½†æ˜¯ç”±äºæ“ä½œç³»ç»Ÿè°ƒåº¦çº¿ç¨‹å¸¦æ¥çš„çº¿ç¨‹é˜»å¡ä¼šä½¿ç¨‹åºå“åº”é€Ÿåº¦å˜æ…¢ã€‚

![image-20210203101946405](img/image-20210203101946405.png)



## è¯·æè¿°synchrnoizedå’Œreentrantlockçš„åº•å±‚å®ç°åŠé‡å…¥çš„åº•å±‚åŸç† - ç™¾åº¦ é˜¿é‡Œ

### synchronizedåº•å±‚åŸç†

å‚è€ƒèµ„æ–™ï¼š[jvmï¼šObjectMonitoræºç ](https://blog.csdn.net/zwjyyy1203/article/details/106217887)

#### é‡é‡çº§é”

synchronizedé‡é‡çº§é”æ˜¯é€šè¿‡monitoræœºåˆ¶å®ç°çš„ï¼Œåœ¨HotSpotè™šæ‹Ÿæœºä¸­ï¼Œmonitoræ˜¯ç”±C++ä¸­ObjectMonitorå®ç°ï¼Œæºç åœ°å€ï¼š[objectMonitor.hpp](https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.hpp)ï¼š

```c++
// ObjectWaiter serves as a "proxy" or surrogate thread.
// TODO-FIXME: Eliminate ObjectWaiter and use the thread-specific
// ParkEvent instead.  Beware, however, that the JVMTI code
// knows about ObjectWaiters, so we'll have to reconcile that code.
// See next_waiter(), first_waiter(), etc.

class ObjectWaiter : public StackObj {
 public:
  enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ } ;
  enum Sorted  { PREPEND, APPEND, SORTED } ;
  ObjectWaiter * volatile _next;
  ObjectWaiter * volatile _prev;
  Thread*       _thread;
  jlong         _notifier_tid;
  ParkEvent *   _event;
  volatile int  _notified ;
  volatile TStates TState ;
  Sorted        _Sorted ;           // List placement disposition
  bool          _active ;           // Contention monitoring is enabled
 public:
  ObjectWaiter(Thread* thread);

  void wait_reenter_begin(ObjectMonitor *mon);
  void wait_reenter_end(ObjectMonitor *mon);
};


class ObjectMonitor {
  // initialize the monitor, exception the semaphore, all other fields
  // are simple integers or pointers
  ObjectMonitor() {
    _header       = NULL;
    _count        = 0;
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL;
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
    _previous_owner_tid = 0;
  }

 private:
  friend class ObjectSynchronizer;
  friend class ObjectWaiter;
  friend class VMStructs;

  // WARNING: this must be the very first word of ObjectMonitor
  // This means this class can't use any virtual member functions.

  volatile markOop   _header;       // displaced object header word - mark
  void*     volatile _object;       // backward object pointer - strong root

  double SharingPad [1] ;           // temp to reduce false sharing

  // All the following fields must be machine word aligned
  // The VM assumes write ordering wrt these fields, which can be
  // read from other threads.

 protected:                         // protected for jvmtiRawMonitor
  void *  volatile _owner;          // pointer to owning thread OR BasicLock
  volatile jlong _previous_owner_tid; // thread id of the previous owner of the monitor
  volatile intptr_t  _recursions;   // recursion count, 0 for first entry
 private:
  int OwnerIsThread ;               // _owner is (Thread *) vs SP/BasicLock
  ObjectWaiter * volatile _cxq ;    // LL of recently-arrived threads blocked on entry.
                                    // The list is actually composed of WaitNodes, acting
                                    // as proxies for Threads.
 protected:
  ObjectWaiter * volatile _EntryList ;     // Threads blocked on entry or reentry.
 private:
  Thread * volatile _succ ;          // Heir presumptive thread - used for futile wakeup throttling
  Thread * volatile _Responsible ;
  int _PromptDrain ;                // rqst to drain cxq into EntryList ASAP

  volatile int _Spinner ;           // for exit->spinner handoff optimization
  volatile int _SpinFreq ;          // Spin 1-out-of-N attempts: success rate
  volatile int _SpinClock ;
  volatile int _SpinDuration ;
  volatile intptr_t _SpinState ;    // MCS/CLH list of spinners

  // TODO-FIXME: _count, _waiters and _recursions should be of
  // type int, or int32_t but not intptr_t.  There's no reason
  // to use 64-bit fields for these variables on a 64-bit JVM.

  volatile intptr_t  _count;        // reference count to prevent reclaimation/deflation
                                    // at stop-the-world time.  See deflate_idle_monitors().
                                    // _count is approximately |_WaitSet| + |_EntryList|
 protected:
  volatile intptr_t  _waiters;      // number of waiting threads
 private:
 protected:
  ObjectWaiter * volatile _WaitSet; // LL of threads wait()ing on the monitor
 private:
  volatile int _WaitSetLock;        // protects Wait Queue - simple spinlock

 public:
  int _QMix ;                       // Mixed prepend queue discipline
  ObjectMonitor * FreeNext ;        // Free list linkage
  intptr_t StatA, StatsB ;
};
```

é‡é‡çº§é”çš„åŠ é”è°ƒç”¨äº†[ObjectMonitor.cpp](https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.cpp)ä¸­çš„enteræ–¹æ³•

```java
void ATTR ObjectMonitor::enter(TRAPS) {
  Thread * const Self = THREAD ;
  void * cur ;
  //é€šè¿‡CASæ“ä½œå°è¯•æŠŠmonitorçš„_ownerå­—æ®µè®¾ç½®ä¸ºå½“å‰çº¿ç¨‹
  cur = Atomic::cmpxchg_ptr (Self, &_owner, NULL) ;
  //è·å–é”å¤±è´¥
  if (cur == NULL) {
     assert (_recursions == 0   , "invariant") ;
     assert (_owner      == Self, "invariant") ;
     return ;
  }
 
//å¦‚æœä¹‹å‰çš„_owneræŒ‡å‘è¯¥THREADï¼Œé‚£ä¹ˆè¯¥çº¿ç¨‹æ˜¯é‡å…¥ï¼Œ_recursions++
  if (cur == Self) {
     _recursions ++ ;
     return ;
  }
//å¦‚æœå½“å‰çº¿ç¨‹æ˜¯ç¬¬ä¸€æ¬¡è¿›å…¥è¯¥monitorï¼Œè®¾ç½®_recursionsä¸º1ï¼Œ_ownerä¸ºå½“å‰çº¿ç¨‹
  if (Self->is_lock_owned ((address)cur)) {
    assert (_recursions == 0, "internal state error");
    _recursions = 1 ;   //_recursionsæ ‡è®°ä¸º1
    _owner = Self ;     //è®¾ç½®owner
    OwnerIsThread = 1 ;
    return ;
  }

  Self->_Stalled = intptr_t(this) ;
  //TrySpinæ˜¯ä¸€ä¸ªè‡ªæ—‹è·å–é”çš„æ“ä½œï¼Œæ­¤å¤„å°±ä¸åˆ—å‡ºæºç äº†
  if (Knob_SpinEarly && TrySpin (Self) > 0) {
     Self->_Stalled = 0 ;
     return ;
  }
  /*
  *çœç•¥éƒ¨åˆ†ä»£ç 
  */
    for (;;) {
      EnterI (THREAD) ;
      /**
      *çœç•¥äº†éƒ¨åˆ†ä»£ç 
      **/
  }
}
```

1. å¦‚æœmonitorçš„æœªè¢«å ç”¨ï¼Œåˆ™è¯¥çº¿ç¨‹è¿›å…¥monitorï¼Œç„¶åå°†_recursionsè®¾ç½®ä¸º1ï¼Œè¯¥çº¿ç¨‹å³ä¸ºmonitorçš„owner
2. å¦‚æœçº¿ç¨‹å·²ç»å æœ‰è¯¥monitorï¼Œåªæ˜¯é‡æ–°è¿›å…¥ï¼Œåˆ™_recursionsåŠ 1.
3. å¦‚æœå…¶ä»–çº¿ç¨‹å·²ç»å ç”¨äº†monitorï¼Œåˆ™è¯¥çº¿ç¨‹è¿›å…¥é˜»å¡çŠ¶æ€ï¼Œç›´åˆ°monitorçš„è¿›å…¥æ•°ä¸º0ï¼Œå†é‡æ–°å°è¯•è·å–monitorçš„æ‰€æœ‰æƒ

**é”ğŸ”’æ‰§è¡Œæ•ˆæœå¦‚ä¸‹**ï¼š

![å›¾ 15-06ï¼Œé”ğŸ”’æ‰§è¡Œæ•ˆæœ](img/39c9b275935890d35682c5c06b67e82a.png)

é‡é‡çº§é”çš„è§£é”è°ƒç”¨äº†[ObjectMonitor.cpp](https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.cpp)ä¸­çš„exitæ–¹æ³•

```java
void ATTR ObjectMonitor::exit(TRAPS) {
   Thread * Self = THREAD ;
   if (THREAD != _owner) {
     if (THREAD->is_lock_owned((address) _owner)) {
       _owner = THREAD ;
       _recursions = 0 ;
       OwnerIsThread = 1 ;
     } else {
       TEVENT (Exit - Throw IMSX) ;
       if (false) {
          THROW(vmSymbols::java_lang_IllegalMonitorStateException());
       }
       return;
     }
   }
   if (_recursions != 0) {
     _recursions--;        // å¦‚æœ_recursionsæ¬¡æ•°ä¸ä¸º0.è‡ªå‡
     TEVENT (Inflated exit - recursive) ;
     return ;
   }
   if ((SyncFlags & 4) == 0) {
      _Responsible = NULL ;
   }
 
   for (;;) {
      if (Knob_ExitPolicy == 0) {
         OrderAccess::release_store_ptr (&_owner, NULL) ;   // drop the lock
         OrderAccess::storeload() ;                         
         if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {
            TEVENT (Inflated exit - simple egress) ;
            return ;
         }
         TEVENT (Inflated exit - complex egress) ;
         if (Atomic::cmpxchg_ptr (THREAD, &_owner, NULL) != NULL) {
            return ;
         }
         TEVENT (Exit - Reacquired) ;
      } else {
         if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {
            OrderAccess::release_store_ptr (&_owner, NULL) ;  
            OrderAccess::storeload() ;
            if (_cxq == NULL || _succ != NULL) {
                TEVENT (Inflated exit - simple egress) ;
                return ;
            }
            if (Atomic::cmpxchg_ptr (THREAD, &_owner, NULL) != NULL) {
               TEVENT (Inflated exit - reacquired succeeded) ;
               return ;
            }
            TEVENT (Inflated exit - reacquired failed) ;
         } else {
            TEVENT (Inflated exit - complex egress) ;
         }
      }
      ObjectWaiter * w = NULL ;
      int QMode = Knob_QMode ;
      if (QMode == 2 && _cxq != NULL) {
          /**
          *æ¨¡å¼2:cxqé˜Ÿåˆ—çš„ä¼˜å…ˆæƒå¤§äºEntryListï¼Œç›´æ¥ä»cxqé˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªçº¿ç¨‹ç»“ç‚¹ï¼Œå‡†å¤‡å”¤é†’
          **/
          w = _cxq ;
          ExitEpilog (Self, w) ;
          return ;
      }
 
      if (QMode == 3 && _cxq != NULL) {
          /**
          *æ¨¡å¼3:å°†cxqé˜Ÿåˆ—æ’å…¥åˆ°_EntryListå°¾éƒ¨
          **/
          w = _cxq ;
          for (;;) {
             //CASæ“ä½œå–å‡ºcxqé˜Ÿåˆ—é¦–ç»“ç‚¹
             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &_cxq, w) ;
             if (u == w) break ;
             w = u ; //æ›´æ–°wï¼Œè‡ªæ—‹
          }
          ObjectWaiter * q = NULL ;
          ObjectWaiter * p ;
          for (p = w ; p != NULL ; p = p->_next) {
              guarantee (p->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
              p->TState = ObjectWaiter::TS_ENTER ; //æ”¹å˜ObjectWaiterçŠ¶æ€
              //ä¸‹é¢ä¸¤å¥ä¸ºcxqé˜Ÿåˆ—åå‘æ„é€ ä¸€æ¡é“¾ï¼Œå³å°†cxqå˜æˆåŒå‘é“¾è¡¨
              p->_prev = q ;
              q = p ;
          }
          ObjectWaiter * Tail ;
          //è·å¾—_EntryListå°¾ç»“ç‚¹
          for (Tail = _EntryList ; Tail != NULL && Tail->_next != NULL ; Tail = Tail->_next) ;
          if (Tail == NULL) {
              _EntryList = w ;//_EntryListä¸ºç©ºï¼Œ_EntryList=w
          } else {
              //å°†wæ’å…¥_EntryListé˜Ÿåˆ—å°¾éƒ¨
              Tail->_next = w ;
              w->_prev = Tail ;
          }
   }
 
      if (QMode == 4 && _cxq != NULL) {
         /**
         *æ¨¡å¼å››ï¼šå°†cxqé˜Ÿåˆ—æ’å…¥åˆ°_EntryListå¤´éƒ¨
         **/
          w = _cxq ;
          for (;;) {
             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &_cxq, w) ;
             if (u == w) break ;
             w = u ;
          }
          ObjectWaiter * q = NULL ;
          ObjectWaiter * p ;
          for (p = w ; p != NULL ; p = p->_next) {
              guarantee (p->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
              p->TState = ObjectWaiter::TS_ENTER ;
              p->_prev = q ;
              q = p ;
          }
          if (_EntryList != NULL) {
            //qä¸ºcxqé˜Ÿåˆ—æœ€åä¸€ä¸ªç»“ç‚¹
              q->_next = _EntryList ;
              _EntryList->_prev = q ;
          }
          _EntryList = w ;
       }
 
      w = _EntryList  ;
      if (w != NULL) {
          ExitEpilog (Self, w) ;//ä»_EntryListä¸­å”¤é†’çº¿ç¨‹
          return ;
      }
      w = _cxq ;
      if (w == NULL) continue ; //å¦‚æœ_cxqå’Œ_EntryListé˜Ÿåˆ—éƒ½ä¸ºç©ºï¼Œè‡ªæ—‹
 
      for (;;) {
          //è‡ªæ—‹å†è·å¾—cxqé¦–ç»“ç‚¹
          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &_cxq, w) ;
          if (u == w) break ;
          w = u ;
      }
      /**
      *ä¸‹é¢æ‰§è¡Œçš„æ˜¯ï¼šcxqä¸ä¸ºç©ºï¼Œ_EntryListä¸ºç©ºçš„æƒ…å†µ
      **/
      if (QMode == 1) {//ç»“åˆå‰é¢çš„ä»£ç ï¼Œå¦‚æœQMode == 1ï¼Œ_EntryListä¸ä¸ºç©ºï¼Œç›´æ¥ä»_EntryListä¸­å”¤é†’çº¿ç¨‹
         // QMode == 1 : drain cxq to EntryList, reversing order
         // We also reverse the order of the list.
         ObjectWaiter * s = NULL ;
         ObjectWaiter * t = w ;
         ObjectWaiter * u = NULL ;
         while (t != NULL) {
             guarantee (t->TState == ObjectWaiter::TS_CXQ, "invariant") ;
             t->TState = ObjectWaiter::TS_ENTER ;
             //ä¸‹é¢çš„æ“ä½œæ˜¯åŒå‘é“¾è¡¨çš„å€’ç½®
             u = t->_next ;
             t->_prev = u ;
             t->_next = s ;
             s = t;
             t = u ;
         }
         _EntryList  = s ;//_EntryListä¸ºå€’ç½®åçš„cxqé˜Ÿåˆ—
      } else {
         // QMode == 0 or QMode == 2
         _EntryList = w ;
         ObjectWaiter * q = NULL ;
         ObjectWaiter * p ;
         for (p = w ; p != NULL ; p = p->_next) {
             guarantee (p->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
             p->TState = ObjectWaiter::TS_ENTER ;
             //æ„é€ æˆåŒå‘çš„
             p->_prev = q ;
             q = p ;
         }
      }
      if (_succ != NULL) continue;
      w = _EntryList  ;
      if (w != NULL) {
          ExitEpilog (Self, w) ; //ä»_EntryListä¸­å”¤é†’çº¿ç¨‹
          return ;
      }
   }
}
```

#### åå‘é”ã€è½»é‡çº§é”

synchronizedçš„åå‘é”ã€è½»é‡çº§é”æ˜¯é€šè¿‡æ”¹å˜å¯¹è±¡å¤´ä¿¡æ¯å®ç°çš„ï¼Œå…¶åº•å±‚ä»£ç åœ¨[synchronizer.cpp](https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/synchronizer.cpp)

- åå‘é”çš„åŠ é”è°ƒç”¨äº†fast_enteræ–¹æ³•

  - å°†å¯¹è±¡å¤´ä¸­çš„Mark Wordçš„é”æ ‡å¿—ä½ä¿®æ”¹ä¸ºåå‘é”
  - åœ¨å¯¹è±¡å¤´çš„Mark Wordä¸­ä¿å­˜å½“å‰çº¿ç¨‹çš„id

  ```c++
  //åå‘é”å…¥å£
  void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) {
   //UseBiasedLockingåˆ¤æ–­æ˜¯å¦å¼€å¯åå‘é”
   if (UseBiasedLocking) {
      if (!SafepointSynchronize::is_at_safepoint()) {
        //è·å–åå‘é”çš„å‡½æ•°è°ƒç”¨
        BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);
        if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {
          return;
        }
      } else {
        assert(!attempt_rebias, "can not rebias toward VM thread");
        BiasedLocking::revoke_at_safepoint(obj);
      }
   }
   //ä¸èƒ½åå‘ï¼Œå°±è·å–è½»é‡çº§é”
   slow_enter (obj, lock, THREAD) ;
  }
  ```

- è½»é‡çº§é”çš„åŠ é”è°ƒç”¨äº†slow_enteræ–¹æ³•

  - å°†å¯¹è±¡å¤´ä¸­çš„Mark Wordçš„é”æ ‡å¿—ä½ä¿®æ”¹ä¸ºè½»é‡çº§é”
  - å°†Mark Wordå†™å…¥å½“å‰çº¿ç¨‹æ ˆçš„header
  - å°†Mark Wordæ›´æ–°ä¸ºæŒ‡å‘Lock Recordçš„æŒ‡é’ˆ
  - owneræŒ‡å‘Mark Word

  ```c++
  //è½»é‡çº§é”å…¥å£
  void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {
    markOop mark = obj->mark();  //è·å¾—Mark Word
    assert(!mark->has_bias_pattern(), "should not see bias pattern here");
    //æ˜¯å¦æ— é”ä¸å¯åå‘ï¼Œæ ‡å¿—001
    if (mark->is_neutral()) {
      //å›¾Aæ­¥éª¤1
      lock->set_displaced_header(mark);
      //å›¾Aæ­¥éª¤2
      if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {
        TEVENT (slow_enter: release stacklock) ;
        return ;
      }
      // Fall through to inflate() ...
    } else if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) { //å¦‚æœMark WordæŒ‡å‘æœ¬åœ°æ ˆå¸§ï¼Œçº¿ç¨‹é‡å…¥
      assert(lock != mark->locker(), "must not re-lock the same lock");
      assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
      lock->set_displaced_header(NULL);//headerè®¾ç½®ä¸ºnull
      return;
    }
    lock->set_displace
   
    d_header(markOopDesc::unused_mark());
    //è½»é‡çº§é”è†¨èƒ€ï¼Œè†¨èƒ€å®Œæˆä¹‹åå°è¯•è·å–é‡é‡çº§é”
    ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
  }
  ```

  ![img](img/aHR0cHM6Ly93d3cubGludXhpZGMuY29tL3VwbG9hZC8yMDE4XzAyLzE4MDIwNjIxNTM3MjMzMTQucG5n)

  1ã€å°†Mark Wordå†™å…¥header

  2ã€å°†Mark Wordæ›´æ–°ä¸ºæŒ‡å‘Lock Recordçš„æŒ‡é’ˆ

  3ã€owneræŒ‡å‘Mark Word

- åå‘é”çš„è§£é”å’Œè½»é‡çº§é”çš„è§£é”éƒ½è°ƒç”¨äº†fast_exitæ–¹æ³•

  ```c++
  void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {
    assert(!object->mark()->has_bias_pattern(), "should not see bias pattern here");
    markOop dhw = lock->displaced_header();
    markOop mark ;
    if (dhw == NULL) {//å¦‚æœheaderä¸ºnullï¼Œè¯´æ˜è¿™æ˜¯çº¿ç¨‹é‡å…¥çš„æ ˆå¸§ï¼Œç›´æ¥è¿”å›ï¼Œä¸ç”¨å›å†™
       mark = object->mark() ;
       assert (!mark->is_neutral(), "invariant") ;
       if (mark->has_locker() && mark != markOopDesc::INFLATING()) {
          assert(THREAD->is_lock_owned((address)mark->locker()), "invariant") ;
       }
       if (mark->has_monitor()) {
          ObjectMonitor * m = mark->monitor() ;
       }
       return ;
    }
   
    mark = object->mark() ;
    if (mark == (markOop) lock) {
       assert (dhw->is_neutral(), "invariant") ;
       //CASå°†Mark Wordå†…å®¹å†™å›
       if ((markOop) Atomic::cmpxchg_ptr (dhw, object->mark_addr(), mark) == mark) {
          TEVENT (fast_exit: release stacklock) ;
          return;
       }
    }
    //CASæ“ä½œå¤±è´¥ï¼Œè½»é‡çº§é”è†¨èƒ€ï¼Œä¸ºä»€ä¹ˆåœ¨æ’¤é”€é”çš„æ—¶å€™ä¼šæœ‰å¤±è´¥çš„å¯èƒ½ï¼Ÿ
     ObjectSynchronizer::inflate(THREAD, object)->exit (THREAD) ;
  }
  
  void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {
    fast_exit (object, lock, THREAD) ;
  }
  ```


### ReentrantLockåº•å±‚åŸç†

ReentrantLockæ˜¯åŸºäºAQSå®ç°çš„ï¼Œå…¶æºç åˆ†æå¦‚ä¸‹ï¼š

**æ— å‚æ„é€ å™¨ï¼ˆé»˜è®¤ä¸ºéå…¬å¹³é”ï¼‰**

```java
public ReentrantLock() {
    sync = new NonfairSync();//é»˜è®¤æ˜¯éå…¬å¹³çš„
}
```

**å¸¦å¸ƒå°”å€¼çš„æ„é€ å™¨ï¼ˆæ˜¯å¦å…¬å¹³ï¼‰**

```java
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();//fairä¸ºtrueï¼Œå…¬å¹³é”ï¼›åä¹‹ï¼Œéå…¬å¹³é”
}
```

ReentrantLockå†…éƒ¨å®šä¹‰äº†ä¸‰ä¸ªé‡è¦çš„é™æ€å†…éƒ¨ç±»ï¼ŒSyncã€NonFairSyncã€FairSyncã€‚Syncä½œä¸ºReentrantLockä¸­å…¬ç”¨çš„åŒæ­¥ç»„ä»¶ï¼Œç»§æ‰¿äº†AQSï¼ˆè¦åˆ©ç”¨AQSå¤æ‚çš„é¡¶å±‚é€»è¾‘å˜›ï¼Œçº¿ç¨‹æ’é˜Ÿï¼Œé˜»å¡ï¼Œå”¤é†’ç­‰ç­‰ï¼‰ï¼›NonFairSyncå’ŒFairSyncåˆ™éƒ½ç»§æ‰¿Syncï¼Œè°ƒç”¨Syncçš„å…¬ç”¨é€»è¾‘ï¼Œç„¶åå†åœ¨å„è‡ªå†…éƒ¨å®Œæˆè‡ªå·±ç‰¹å®šçš„é€»è¾‘ï¼ˆå…¬å¹³æˆ–éå…¬å¹³ï¼‰ã€‚

**NonFairSyncï¼ˆéå…¬å¹³å¯é‡å…¥é”ï¼‰**

```java
static final class NonfairSync extends Sync {//ç»§æ‰¿Sync
    private static final long serialVersionUID = 7316153563782823691L;
    /** è·å–é” */
    final void lock() {
        if (compareAndSetState(0, 1))//CASè®¾ç½®stateçŠ¶æ€ï¼Œè‹¥åŸå€¼æ˜¯0ï¼Œå°†å…¶ç½®ä¸º1
            setExclusiveOwnerThread(Thread.currentThread());//å°†å½“å‰çº¿ç¨‹æ ‡è®°ä¸ºå·²æŒæœ‰é”
        else
            acquire(1);//è‹¥è®¾ç½®å¤±è´¥ï¼Œè°ƒç”¨AQSçš„acquireæ–¹æ³•ï¼Œacquireåˆä¼šè°ƒç”¨æˆ‘ä»¬ä¸‹é¢é‡å†™çš„tryAcquireæ–¹æ³•ã€‚è¿™é‡Œè¯´çš„è°ƒç”¨å¤±è´¥æœ‰ä¸¤ç§æƒ…å†µï¼š1å½“å‰æ²¡æœ‰çº¿ç¨‹è·å–åˆ°èµ„æºï¼Œstateä¸º0ï¼Œä½†æ˜¯å°†stateç”±0è®¾ç½®ä¸º1çš„æ—¶å€™ï¼Œå…¶ä»–çº¿ç¨‹æŠ¢å èµ„æºï¼Œå°†stateä¿®æ”¹äº†ï¼Œå¯¼è‡´äº†CASå¤±è´¥ï¼›2 stateåŸæœ¬å°±ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯å·²ç»æœ‰çº¿ç¨‹è·å–åˆ°èµ„æºäº†ï¼Œæœ‰å¯èƒ½æ˜¯åˆ«çš„çº¿ç¨‹è·å–åˆ°èµ„æºï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å½“å‰çº¿ç¨‹è·å–çš„ï¼Œè¿™æ—¶çº¿ç¨‹åˆé‡å¤å»è·å–ï¼Œæ‰€ä»¥å»tryAcquireä¸­çš„nonfairTryAcquireæˆ‘ä»¬åº”è¯¥å°±èƒ½çœ‹åˆ°å¯é‡å…¥çš„å®ç°é€»è¾‘äº†ã€‚
    }
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);//è°ƒç”¨Syncä¸­çš„æ–¹æ³•
    }
}

final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();//è·å–å½“å‰çº¿ç¨‹
    int c = getState();//è·å–å½“å‰stateå€¼
    if (c == 0) {//è‹¥stateä¸º0ï¼Œæ„å‘³ç€æ²¡æœ‰çº¿ç¨‹è·å–åˆ°èµ„æºï¼ŒCASå°†stateè®¾ç½®ä¸º1ï¼Œå¹¶å°†å½“å‰çº¿ç¨‹æ ‡è®°æˆ‘è·å–åˆ°æ’ä»–é”çš„çº¿ç¨‹ï¼Œè¿”å›true
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {//è‹¥stateä¸ä¸º0ï¼Œä½†æ˜¯æŒæœ‰é”çš„çº¿ç¨‹æ˜¯å½“å‰çº¿ç¨‹
        int nextc = c + acquires;//stateç´¯åŠ 1
        if (nextc < 0) // intç±»å‹æº¢å‡ºäº†
            throw new Error("Maximum lock count exceeded");
        setState(nextc);//è®¾ç½®stateï¼Œæ­¤æ—¶stateå¤§äº1ï¼Œä»£è¡¨ç€ä¸€ä¸ªçº¿ç¨‹å¤šæ¬¡è·é”ï¼Œstateçš„å€¼å³æ˜¯çº¿ç¨‹é‡å…¥çš„æ¬¡æ•°
        return true;//è¿”å›trueï¼Œè·å–é”æˆåŠŸ
    }
    return false;//è·å–é”å¤±è´¥äº†
}
```

ç®€å•æ€»ç»“ä¸‹æµç¨‹ï¼š

1. å…ˆè·å–stateå€¼ï¼Œè‹¥ä¸º0ï¼Œæ„å‘³ç€æ­¤æ—¶æ²¡æœ‰çº¿ç¨‹è·å–åˆ°èµ„æºï¼ŒCASå°†å…¶è®¾ç½®ä¸º1ï¼Œè®¾ç½®æˆåŠŸåˆ™ä»£è¡¨è·å–åˆ°æ’ä»–é”äº†ï¼›

2. è‹¥stateå¤§äº0ï¼Œè‚¯å®šæœ‰çº¿ç¨‹å·²ç»æŠ¢å åˆ°èµ„æºäº†ï¼Œæ­¤æ—¶å†å»åˆ¤æ–­æ˜¯å¦å°±æ˜¯è‡ªå·±æŠ¢å çš„ï¼Œæ˜¯çš„è¯ï¼Œstateç´¯åŠ ï¼Œè¿”å›trueï¼Œé‡å…¥æˆåŠŸï¼Œstateçš„å€¼å³æ˜¯çº¿ç¨‹é‡å…¥çš„æ¬¡æ•°ï¼›

3. å…¶ä»–æƒ…å†µï¼Œåˆ™è·å–é”å¤±è´¥ã€‚

**FairSync(å¯é‡å…¥å…¬å¹³é”)**

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);//ç›´æ¥è°ƒç”¨AQSçš„æ¨¡æ¿æ–¹æ³•acquireï¼Œacquireä¼šè°ƒç”¨ä¸‹é¢æˆ‘ä»¬é‡å†™çš„è¿™ä¸ªtryAcquire
    }

    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();//è·å–å½“å‰çº¿ç¨‹
        int c = getState();//è·å–stateå€¼
        if (c == 0) {//è‹¥stateä¸º0ï¼Œæ„å‘³ç€å½“å‰æ²¡æœ‰çº¿ç¨‹è·å–åˆ°èµ„æºï¼Œé‚£å°±å¯ä»¥ç›´æ¥è·å–èµ„æºäº†å—ï¼ŸNO!è¿™ä¸å°±è·Ÿä¹‹å‰çš„éå…¬å¹³é”çš„é€»è¾‘ä¸€æ ·äº†å˜›ã€‚çœ‹ä¸‹é¢çš„é€»è¾‘
            if (!hasQueuedPredecessors() &&//åˆ¤æ–­åœ¨æ—¶é—´é¡ºåºä¸Šï¼Œæ˜¯å¦æœ‰ç”³è¯·é”æ’åœ¨è‡ªå·±ä¹‹å‰çš„çº¿ç¨‹ï¼Œè‹¥æ²¡æœ‰ï¼Œæ‰èƒ½å»è·å–ï¼ŒCASè®¾ç½®stateï¼Œå¹¶æ ‡è®°å½“å‰çº¿ç¨‹ä¸ºæŒæœ‰æ’ä»–é”çš„çº¿ç¨‹ï¼›åä¹‹ï¼Œä¸èƒ½è·å–ï¼è¿™å³æ˜¯å…¬å¹³çš„å¤„ç†æ–¹å¼ã€‚
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {//é‡å…¥çš„å¤„ç†é€»è¾‘ï¼Œä¸ä¸Šæ–‡ä¸€è‡´ï¼Œä¸å†èµ˜è¿°
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}

public final boolean hasQueuedPredecessors() {
    Node t = tail; // å°¾ç»“ç‚¹
    Node h = head;//å¤´ç»“ç‚¹
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());//åˆ¤æ–­æ˜¯å¦æœ‰æ’åœ¨è‡ªå·±ä¹‹å‰çš„çº¿ç¨‹
}
```

**å¯ä»¥çœ‹åˆ°ï¼Œå…¬å¹³é”çš„å¤§è‡´é€»è¾‘ä¸éå…¬å¹³é”æ˜¯ä¸€è‡´çš„ï¼Œä¸åŒçš„åœ°æ–¹åœ¨äºæœ‰äº†!hasQueuedPredecessors()è¿™ä¸ªåˆ¤æ–­é€»è¾‘ï¼Œå³ä¾¿stateä¸º0ï¼Œä¹Ÿä¸èƒ½è´¸ç„¶ç›´æ¥å»è·å–ï¼Œè¦å…ˆå»çœ‹æœ‰æ²¡æœ‰è¿˜åœ¨æ’é˜Ÿçš„çº¿ç¨‹ï¼Œè‹¥æ²¡æœ‰ï¼Œæ‰èƒ½å°è¯•å»è·å–ï¼Œåšåé¢çš„å¤„ç†ã€‚åä¹‹ï¼Œè¿”å›falseï¼Œè·å–å¤±è´¥ã€‚**

æœ€åï¼Œæ¥çœ‹çœ‹ReentrantLockçš„tryReleaseï¼Œå®šä¹‰åœ¨Syncä¸­

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;//å‡å»1ä¸ªèµ„æº
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    //è‹¥stateå€¼ä¸º0ï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹å·²å®Œå…¨é‡Šæ”¾å¹²å‡€ï¼Œè¿”å›trueï¼Œä¸Šå±‚çš„AQSä¼šæ„è¯†åˆ°èµ„æºå·²ç©ºå‡ºã€‚è‹¥ä¸ä¸º0ï¼Œåˆ™è¡¨ç¤ºçº¿ç¨‹è¿˜å æœ‰èµ„æºï¼Œåªä¸è¿‡å°†æ­¤æ¬¡é‡å…¥çš„èµ„æºçš„é‡Šæ”¾äº†è€Œå·²ï¼Œè¿”å›falseã€‚
    if (c == 0) {
        free = true;//
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

#### lock

1ã€ç¬¬ä¸€æ­¥ã€‚å°è¯•å»è·å–é”ã€‚å¦‚æœå°è¯•è·å–é”æˆåŠŸï¼Œæ–¹æ³•ç›´æ¥è¿”å›ã€‚

2ã€ç¬¬äºŒæ­¥ï¼Œå…¥é˜Ÿã€‚ç”±äºä¸Šæ–‡ä¸­æåˆ°çº¿ç¨‹Aå·²ç»å ç”¨äº†é”ï¼Œæ‰€ä»¥Bå’ŒCæ‰§è¡ŒtryAcquireå¤±è´¥ï¼Œå¹¶ä¸”å…¥ç­‰å¾…é˜Ÿåˆ—ã€‚å¦‚æœçº¿ç¨‹Aæ‹¿ç€é”æ­»æ­»ä¸æ”¾ï¼Œé‚£ä¹ˆBå’ŒCå°±ä¼šè¢«æŒ‚èµ·ã€‚

3ã€ç¬¬ä¸‰æ­¥ï¼ŒæŒ‚èµ·ã€‚Bå’ŒCç›¸ç»§æ‰§è¡ŒacquireQueued(final Node node, int arg)ã€‚è¿™ä¸ªæ–¹æ³•è®©å·²ç»å…¥é˜Ÿçš„çº¿ç¨‹å°è¯•è·å–é”ï¼Œè‹¥å¤±è´¥åˆ™ä¼šè¢«æŒ‚èµ·ã€‚

çº¿ç¨‹å…¥é˜Ÿåèƒ½å¤ŸæŒ‚èµ·çš„å‰ææ˜¯ï¼Œå®ƒçš„å‰é©±èŠ‚ç‚¹çš„çŠ¶æ€ä¸ºSIGNALï¼Œå®ƒçš„å«ä¹‰æ˜¯â€œHiï¼Œå‰é¢çš„å…„å¼Ÿï¼Œå¦‚æœä½ è·å–é”å¹¶ä¸”å‡ºé˜Ÿåï¼Œè®°å¾—æŠŠæˆ‘å”¤é†’ï¼â€ã€‚æ‰€ä»¥shouldParkAfterFailedAcquireä¼šå…ˆåˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å‰é©±æ˜¯å¦çŠ¶æ€ç¬¦åˆè¦æ±‚ï¼Œè‹¥ç¬¦åˆåˆ™è¿”å›trueï¼Œç„¶åè°ƒç”¨parkAndCheckInterruptï¼Œå°†è‡ªå·±æŒ‚èµ·ã€‚å¦‚æœä¸ç¬¦åˆï¼Œå†çœ‹å‰é©±èŠ‚ç‚¹æ˜¯å¦>0(CANCELLED)ï¼Œè‹¥æ˜¯é‚£ä¹ˆå‘å‰éå†ç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆè¦æ±‚çš„å‰é©±ï¼Œè‹¥ä¸æ˜¯åˆ™å°†å‰é©±èŠ‚ç‚¹çš„çŠ¶æ€è®¾ç½®ä¸ºSIGNALã€‚

 æ•´ä¸ªæµç¨‹ä¸­ï¼Œå¦‚æœå‰é©±ç»“ç‚¹çš„çŠ¶æ€ä¸æ˜¯SIGNALï¼Œé‚£ä¹ˆè‡ªå·±å°±ä¸èƒ½å®‰å¿ƒæŒ‚èµ·ï¼Œéœ€è¦å»æ‰¾ä¸ªå®‰å¿ƒçš„æŒ‚èµ·ç‚¹ï¼ŒåŒæ—¶å¯ä»¥å†å°è¯•ä¸‹çœ‹æœ‰æ²¡æœ‰æœºä¼šå»å°è¯•ç«äº‰é”ã€‚

æœ€ç»ˆé˜Ÿåˆ—å¯èƒ½ä¼šå¦‚ä¸‹å›¾æ‰€ç¤º

![img](img/755171-20190429075938978-548418922.png)

```java
static final class Node {
    /** waitStatuså€¼ï¼Œè¡¨ç¤ºçº¿ç¨‹å·²è¢«å–æ¶ˆï¼ˆç­‰å¾…è¶…æ—¶æˆ–è€…è¢«ä¸­æ–­ï¼‰*/
    static final int CANCELLED =  1;
    /** waitStatuså€¼ï¼Œè¡¨ç¤ºåç»§çº¿ç¨‹éœ€è¦è¢«å”¤é†’ï¼ˆunpakingï¼‰*/
    static final int SIGNAL    = -1;
    /**waitStatuså€¼ï¼Œè¡¨ç¤ºç»“ç‚¹çº¿ç¨‹ç­‰å¾…åœ¨conditionä¸Šï¼Œå½“è¢«signalåï¼Œä¼šä»ç­‰å¾…é˜Ÿåˆ—è½¬ç§»åˆ°åŒæ­¥åˆ°é˜Ÿåˆ—ä¸­ */
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2;
    /** waitStatuså€¼ï¼Œè¡¨ç¤ºä¸‹ä¸€æ¬¡å…±äº«å¼åŒæ­¥çŠ¶æ€ä¼šè¢«æ— æ¡ä»¶åœ°ä¼ æ’­ä¸‹å»
        static final int PROPAGATE = -3;
        /** ç­‰å¾…çŠ¶æ€ï¼Œåˆå§‹ä¸º0 */
    volatile int waitStatus;
    /**å½“å‰ç»“ç‚¹çš„å‰é©±ç»“ç‚¹ */
    volatile Node prev;
    /** å½“å‰ç»“ç‚¹çš„åç»§ç»“ç‚¹ */
    volatile Node next;
    /** ä¸å½“å‰ç»“ç‚¹å…³è”çš„æ’é˜Ÿä¸­çš„çº¿ç¨‹ */
    volatile Thread thread;
    /** ...... */
}
```

#### unlock

å¦‚æœç†è§£äº†åŠ é”çš„è¿‡ç¨‹ï¼Œé‚£ä¹ˆè§£é”çœ‹èµ·æ¥å°±å®¹æ˜“å¤šäº†ã€‚æµç¨‹å¤§è‡´ä¸ºå…ˆå°è¯•é‡Šæ”¾é”ï¼Œè‹¥é‡Šæ”¾æˆåŠŸï¼Œé‚£ä¹ˆæŸ¥çœ‹å¤´ç»“ç‚¹çš„çŠ¶æ€æ˜¯å¦ä¸ºSIGNALï¼Œå¦‚æœæ˜¯åˆ™å”¤é†’å¤´ç»“ç‚¹çš„ä¸‹ä¸ªèŠ‚ç‚¹å…³è”çš„çº¿ç¨‹ï¼Œå¦‚æœé‡Šæ”¾å¤±è´¥é‚£ä¹ˆè¿”å›falseè¡¨ç¤ºè§£é”å¤±è´¥ã€‚è¿™é‡Œæˆ‘ä»¬ä¹Ÿå‘ç°äº†ï¼Œæ¯æ¬¡éƒ½åªå”¤èµ·å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å…³è”çš„çº¿ç¨‹ã€‚



## è¯·æè¿°synchronizedå’ŒReentrantLockçš„å¼‚åŒ - é¡ºä¸°

**ç›¸åŒç‚¹ï¼š**

1ã€éƒ½æ˜¯Javaä¸­çš„é”
2ã€éƒ½æ˜¯å¯é‡å…¥é”
3ã€åŠ é”çš„ç›®çš„æ˜¯ä¸ºäº†å®ç°çº¿ç¨‹åŒæ­¥ï¼Œä¿è¯çº¿ç¨‹å®‰å…¨ã€‚ä»–ä»¬éƒ½æ˜¯åŠ é”æ–¹å¼åŒæ­¥ï¼Œè€Œä¸”éƒ½æ˜¯é˜»å¡å¼åŒæ­¥ï¼Œä¹Ÿå°±æ˜¯è¯´å½“ä¸€ä¸ªçº¿ç¨‹è·å–å¯¹è±¡é”ä¹‹åï¼Œè¿›å…¥åŒæ­¥å—ï¼Œå…¶ä»–è®¿é—®è¯¥åŒæ­¥å—çš„çº¿ç¨‹éƒ½å¿…é¡»é˜»å¡åœ¨è¯¥åŒæ­¥å—å¤–é¢ç­‰å¾…ï¼Œè€Œè¿›è¡Œçº¿ç¨‹é˜»å¡å’Œå”¤é†’çš„ä»£ä»·æ˜¯æ¯”è¾ƒé«˜çš„(æ“ä½œç³»ç»Ÿéœ€è¦åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´æ¥å›åˆ‡æ¢ï¼Œä»£ä»·å¾ˆé«˜ï¼Œä¸è¿‡å¯ä»¥é€šè¿‡å¯¹é”ä¼˜åŒ–è¿›è¡Œæ”¹å–„)ã€‚

**ä¸åŒç‚¹ï¼š**

â‘  **åº•å±‚å®ç°**ä¸Šæ¥è¯´ï¼Œsynchronized æ˜¯**JVM**å±‚é¢çš„é”ï¼Œæ˜¯**Javaå…³é”®å­—**ï¼Œé€šè¿‡monitorå¯¹è±¡æ¥å®Œæˆï¼ˆmonitorenterä¸monitorexitï¼‰ï¼Œå¯¹è±¡åªæœ‰åœ¨åŒæ­¥å—æˆ–åŒæ­¥æ–¹æ³•ä¸­æ‰èƒ½è°ƒç”¨wait/notifyæ–¹æ³•ï¼ŒReentrantLock æ˜¯ä»jdk1.5ä»¥æ¥ï¼ˆjava.util.concurrent.locks.Lockï¼‰æä¾›çš„**APIå±‚é¢**çš„é”ã€‚

synchronized çš„å®ç°æ¶‰åŠåˆ°é”çš„å‡çº§ï¼Œå…·ä½“ä¸ºæ— é”ã€åå‘é”ã€è‡ªæ—‹é”ã€å‘OSç”³è¯·é‡é‡çº§é”ï¼ŒReentrantLockå®ç°åˆ™æ˜¯é€šè¿‡åˆ©ç”¨CASï¼ˆCompareAndSwapï¼‰è‡ªæ—‹æœºåˆ¶ä¿è¯çº¿ç¨‹æ“ä½œçš„åŸå­æ€§å’Œvolatileä¿è¯æ•°æ®å¯è§æ€§ä»¥å®ç°é”çš„åŠŸèƒ½ã€‚

```java
synchronized (new Object()){

}

new ReentrantLock();
```

ä½¿ç”¨javap -cå¯¹å¦‚ä¸Šä»£ç è¿›è¡Œåç¼–è¯‘å¾—åˆ°å¦‚ä¸‹ä»£ç ï¼š

![img](img/v2-30eb44a2bf85eb76f5ab066924a86439_720w.jpg)

â‘¡ **æ˜¯å¦å¯æ‰‹åŠ¨é‡Šæ”¾ï¼š**

synchronized ä¸éœ€è¦ç”¨æˆ·å»æ‰‹åŠ¨é‡Šæ”¾é”ï¼Œsynchronized ä»£ç æ‰§è¡Œå®Œåç³»ç»Ÿä¼šè‡ªåŠ¨è®©çº¿ç¨‹é‡Šæ”¾å¯¹é”çš„å ç”¨ï¼› ReentrantLockåˆ™éœ€è¦ç”¨æˆ·å»æ‰‹åŠ¨é‡Šæ”¾é”ï¼Œå¦‚æœæ²¡æœ‰æ‰‹åŠ¨é‡Šæ”¾é”ï¼Œå°±å¯èƒ½å¯¼è‡´æ­»é”ç°è±¡ã€‚ä¸€èˆ¬é€šè¿‡lock()å’Œunlock()æ–¹æ³•é…åˆtry/finallyè¯­å¥å—æ¥å®Œæˆï¼Œä½¿ç”¨é‡Šæ”¾æ›´åŠ çµæ´»ã€‚

```java
private int number = 0;
private Lock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
private AtomicInteger atomicInteger;

public void increment() throws Exception {
    lock.lock();
    try {

        while (number != 0) {
            condition.await();
        }
        //do something
        number++;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        condition.signalAll();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }

}
```

â‘¢ **æ˜¯å¦å¯ä¸­æ–­**

synchronizedæ˜¯ä¸å¯ä¸­æ–­ç±»å‹çš„é”ï¼Œé™¤éåŠ é”çš„ä»£ç ä¸­å‡ºç°å¼‚å¸¸æˆ–æ­£å¸¸æ‰§è¡Œå®Œæˆï¼› ReentrantLockåˆ™å¯ä»¥ä¸­æ–­ï¼Œå¯é€šè¿‡trylock(long timeout,TimeUnit unit)è®¾ç½®è¶…æ—¶æ–¹æ³•ï¼Œæ—¶é—´è¿‡äº†å°±æ”¾å¼ƒç­‰å¾…ï¼›æˆ–è€…å°†lockInterruptibly()æ”¾åˆ°ä»£ç å—ä¸­ï¼Œè°ƒç”¨interruptæ–¹æ³•è¿›è¡Œä¸­æ–­ã€‚

```java
public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}
public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}
```

ReentrantLockä¸­çš„lockInterruptibly()æ–¹æ³•ä½¿å¾—çº¿ç¨‹å¯ä»¥åœ¨è¢«é˜»å¡æ—¶å“åº”ä¸­æ–­ï¼Œæ¯”å¦‚ä¸€ä¸ªçº¿ç¨‹t1é€šè¿‡lockInterruptibly()æ–¹æ³•è·å–åˆ°ä¸€ä¸ªå¯é‡å…¥é”ï¼Œå¹¶æ‰§è¡Œä¸€ä¸ªé•¿æ—¶é—´çš„ä»»åŠ¡ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹é€šè¿‡interrupt()æ–¹æ³•å°±å¯ä»¥ç«‹åˆ»æ‰“æ–­t1çº¿ç¨‹çš„æ‰§è¡Œï¼Œæ¥è·å–t1æŒæœ‰çš„é‚£ä¸ªå¯é‡å…¥é”ã€‚è€Œé€šè¿‡ReentrantLockçš„lock()æ–¹æ³•æˆ–è€…synchronizedæŒæœ‰é”çš„çº¿ç¨‹æ˜¯ä¸ä¼šå“åº”å…¶ä»–çº¿ç¨‹çš„interrupt()æ–¹æ³•çš„ï¼Œç›´åˆ°è¯¥æ–¹æ³•ä¸»åŠ¨é‡Šæ”¾é”ä¹‹åæ‰ä¼šå“åº”interrupt()æ–¹æ³•ã€‚ä¸‹é¢çœ‹ä¸€ä¸ªç¤ºä¾‹ï¼š

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
 
/**
 * æµ‹è¯•ReentrantLockå¯ä¸­æ–­é”çš„æ•ˆæœ
 */
public class ThreadInteruptExample {
    ReentrantLock lock1=new ReentrantLock();
    ReentrantLock lock2=new ReentrantLock();
 
    /**
     * ReentrantLockå“åº”ä¸­æ–­
     * @throws Exception
     */
    public void reentrantLockInterupt() throws Exception{
        Thread t1=new Thread(new ReentrantLockTask(lock1,lock2));
        Thread t2=new Thread(new ReentrantLockTask(lock2,lock1));
        t1.start();
        t2.start();
        System.out.println(t1.getName()+"ä¸­æ–­");
        //ä¸»çº¿ç¨‹ç¡çœ 1ç§’ï¼Œé¿å…çº¿ç¨‹t1ç›´æ¥å“åº”runæ–¹æ³•ä¸­çš„ç¡çœ ä¸­æ–­
        Thread.sleep(1000);
        t1.interrupt();
        //é˜»å¡ä¸»çº¿ç¨‹ï¼Œé¿å…æ‰€æœ‰çº¿ç¨‹ç›´æ¥ç»“æŸï¼Œå½±å“æ­»é”æ•ˆæœ
        Thread.sleep(10000);
    }
 
 
    /**
     * Synchronizedå“åº”ä¸­æ–­
     * @throws Exception
     */
    public void synchronizedInterupt() throws Exception{
        Object syn1=new Object();
        Object syn2=new Object();
        Thread t1=new Thread(new SynchronizedTask(syn1,syn2));
        Thread t2=new Thread(new SynchronizedTask(syn2,syn1));
        t1.start();
        t2.start();
        System.out.println(t1.getName()+"ä¸­æ–­");
        //ä¸»çº¿ç¨‹ç¡çœ 1ç§’ï¼Œé¿å…çº¿ç¨‹t1ç›´æ¥å“åº”runæ–¹æ³•ä¸­çš„ç¡çœ ä¸­æ–­
        Thread.sleep(1000);
        t1.interrupt();
        //é˜»å¡ä¸»çº¿ç¨‹ï¼Œé¿å…æ‰€æœ‰çº¿ç¨‹ç›´æ¥ç»“æŸï¼Œå½±å“æ­»é”æ•ˆæœ
        Thread.sleep(1000);
    }
 
    /**
     * ReentrantLockå®ç°æ­»é”
     */
    static class ReentrantLockTask implements Runnable{
 
        ReentrantLock lock1;
        ReentrantLock lock2;
 
        public ReentrantLockTask(ReentrantLock lock1, ReentrantLock lock2){
            this.lock1=lock1;
            this.lock2=lock2;
        }
 
        @Override
        public void run() {
            try {
                //å¯ä¸­æ–­çš„è·å–é”
                lock1.lockInterruptibly();
                //lock1.lock();
                //ç¡çœ 200æ¯«ç§’ï¼Œä¿è¯ä¸¤ä¸ªçº¿ç¨‹åˆ†åˆ«å·²ç»è·å–åˆ°ä¸¤ä¸ªé”ï¼Œå®ç°ç›¸äº’çš„é”ç­‰å¾…
                TimeUnit.MILLISECONDS.sleep(200);
                //lock2.lock();
                //å¯ä¸­æ–­çš„è·å–é”
                lock2.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock1.unlock();
                lock2.unlock();
                System.out.println("çº¿ç¨‹"+Thread.currentThread().getName()+"æ­£å¸¸ç»“æŸ");
            }
 
        }
    }
 
    /**
     * Synchronizedå®ç°æ­»é”
     */
    static class SynchronizedTask implements Runnable{
 
        Object lock1;
        Object lock2;
 
        public SynchronizedTask(Object lock1, Object lock2){
            this.lock1=lock1;
            this.lock2=lock2;
        }
 
        @Override
        public void run() {
            try {
                synchronized (lock1){
                    //ç¡çœ 200æ¯«ç§’ï¼Œå†è·å–å¦ä¸€ä¸ªé”ï¼Œ
                    //ä¿è¯ä¸¤ä¸ªçº¿ç¨‹åˆ†åˆ«å·²ç»è·å–åˆ°ä¸¤ä¸ªé”ï¼Œå®ç°ç›¸äº’çš„é”ç­‰å¾…
                    Thread.sleep(200);
                    synchronized (lock2){
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println("çº¿ç¨‹"+Thread.currentThread().getName()+"æ­£å¸¸ç»“æŸ");
            }
 
        }
    }
 
    public static void main(String[] args) throws Exception {
        ThreadInteruptExample demo=new ThreadInteruptExample();
        ThreadInteruptExample demo1=new ThreadInteruptExample();
        demo.reentrantLockInterupt();
        demo1.synchronizedInterupt();
    }
 
}
```

å“åº”ä¸­æ–­![img](img/838863-20200403103659335-2023528298.png)

 æ‰§è¡Œå®Œæ¯•æ‰å“åº”ä¸­æ–­-ç°è±¡æ­»é”

![img](img/838863-20200403103805794-386800025.png)

 â‘£ **æ˜¯å¦å…¬å¹³é”**

synchronizedä¸ºéå…¬å¹³é” ReentrantLockåˆ™å³å¯ä»¥é€‰å…¬å¹³é”ä¹Ÿå¯ä»¥é€‰éå…¬å¹³é”ï¼Œé€šè¿‡æ„é€ æ–¹æ³•new ReentrantLockæ—¶ä¼ å…¥booleanå€¼è¿›è¡Œé€‰æ‹©ï¼Œä¸ºç©ºé»˜è®¤falseéå…¬å¹³é”ï¼Œtrueä¸ºå…¬å¹³é”ã€‚

```java
/**
* Creates an instance of {@code ReentrantLock}.
* This is equivalent to using {@code ReentrantLock(false)}.
*/
public ReentrantLock() {
    sync = new NonfairSync();
}

/**
* Creates an instance of {@code ReentrantLock} with the
* given fairness policy.
*
* @param fair {@code true} if this lock should use a fair ordering policy
*/
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

â‘¤ **é”æ˜¯å¦å¯ç»‘å®šæ¡ä»¶Condition**

synchronizedä¸èƒ½ç»‘å®šï¼› ReentrantLocké€šè¿‡ç»‘å®šConditionç»“åˆawait()/singal()æ–¹æ³•å®ç°çº¿ç¨‹çš„ç²¾ç¡®å”¤é†’ï¼Œè€Œä¸æ˜¯åƒsynchronizedé€šè¿‡Objectç±»çš„wait()/notify()/notifyAll()æ–¹æ³•è¦ä¹ˆéšæœºå”¤é†’ä¸€ä¸ªçº¿ç¨‹è¦ä¹ˆå”¤é†’å…¨éƒ¨çº¿ç¨‹ã€‚

```java
ç¤ºä¾‹ï¼šç”¨ReentrantLockç»‘å®šä¸‰ä¸ªæ¡ä»¶å®ç°çº¿ç¨‹Aæ‰“å°ä¸€æ¬¡1ï¼Œçº¿ç¨‹Bæ‰“å°ä¸¤æ¬¡2ï¼Œçº¿ç¨‹Cæ‰“å°ä¸‰æ¬¡3
class Resource {
    private int number = 1;//A:1  B:2  C:3
    private Lock lock = new ReentrantLock();
    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();

    //1 åˆ¤æ–­
    public void print1() {

        lock.lock();

        try {
            //åˆ¤æ–­
            while (number != 1) {
                c1.await();
            }
            //2 do sth
            for (int i = 1; i < 2; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + number);
            }

            //3 é€šçŸ¥
            number = 2;
            c2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    //1 åˆ¤æ–­
    public void print2() {

        lock.lock();

        try {
            //åˆ¤æ–­
            while (number != 2) {
                c2.await();
            }
            //2 do sth
            for (int i = 1; i < 3; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + number);
            }

            //3 é€šçŸ¥
            number = 3;
            c3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    //1 åˆ¤æ–­
    public void print3() {

        lock.lock();

        try {
            //åˆ¤æ–­
            while (number != 3) {
                c3.await();
            }
            //2 do sth
            for (int i = 1; i < 4; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + number);
            }

            //3 é€šçŸ¥
            number = 1;
            c1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

public static void main(String[] args) {
    Resource resource = new Resource();

    new Thread(()->{
        for (int i = 1; i <= 2; i++) {
            resource.print1();
        }
    },"A").start();


    new Thread(()->{
        for (int i = 1; i <= 2; i++) {
            resource.print2();
        }
    },"B").start();


    new Thread(()->{
        for (int i = 1; i <= 2; i++) {
            resource.print3();
        }
    },"C").start();
}
```

è¾“å‡ºç»“æœä¸ºï¼š

A 1 B 2 B 2 C 3 C 3 C 3 A 1 B 2 B 2 C 3 C 3 C 3

â‘¥ **é”çš„å¯¹è±¡**

synchronziedé”çš„æ˜¯å¯¹è±¡ï¼Œé”æ˜¯ä¿å­˜åœ¨å¯¹è±¡å¤´é‡Œé¢çš„ï¼Œæ ¹æ®å¯¹è±¡å¤´æ•°æ®æ¥æ ‡è¯†æ˜¯å¦æœ‰çº¿ç¨‹è·å¾—é”/äº‰æŠ¢é”ï¼›ReentrantLocké”çš„æ˜¯çº¿ç¨‹ï¼Œæ ¹æ®è¿›å…¥çš„çº¿ç¨‹å’Œintç±»å‹çš„stateæ ‡è¯†é”çš„è·å¾—/äº‰æŠ¢ã€‚

â‘¦**çµæ´»æ€§**

synchronizedé”çš„èŒƒå›´æ˜¯æ•´ä¸ªæ–¹æ³•æˆ–synchronizedå—éƒ¨åˆ†ï¼ŒReentrantLockå› ä¸ºæ˜¯æ–¹æ³•è°ƒç”¨ï¼Œå¯ä»¥è·¨æ–¹æ³•ï¼Œçµæ´»æ€§æ›´å¤§ã€‚

â‘§**æä¾›çš„é«˜çº§åŠŸèƒ½**

ReentrantLockæä¾›å¾ˆå¤šæ–¹æ³•ç”¨æ¥ç›‘å¬å½“å‰é”çš„ä¿¡æ¯ï¼Œå¦‚ï¼š

```java
getHoldCount() 
getQueueLength()
isFair()
isHeldByCurrentThread()
isLocked()
```

æ€»ç»“ï¼š

| æ¯”è¾ƒæ–¹é¢         | SynChronized                                                 | ReentrantLockï¼ˆå®ç°äº† Lockæ¥å£ï¼‰                             |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.åŸå§‹æ„æˆ       | 1.å®ƒæ˜¯javaè¯­è¨€çš„å…³é”®å­—ï¼Œæ˜¯åŸç”Ÿè¯­æ³•å±‚é¢çš„äº’æ–¥ï¼Œéœ€è¦jvmå®ç°    | å®ƒæ˜¯JDK 1.5ä¹‹åæä¾›çš„APIå±‚é¢çš„äº’æ–¥é”ç±»                       |
| 2.ä»£ç ç¼–å†™       | 2.é‡‡ç”¨synchronizedä¸éœ€è¦ç”¨æˆ·å»æ‰‹åŠ¨é‡Šæ”¾é”ï¼Œå½“synchronizedæ–¹æ³•æˆ–è€…synchronizedä»£ç å—æ‰§è¡Œå®Œä¹‹åï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è®©çº¿ç¨‹é‡Šæ”¾å¯¹é”çš„å ç”¨ï¼Œæ›´å®‰å…¨ï¼Œ | è€ŒReentrantLockåˆ™å¿…é¡»è¦ç”¨æˆ·å»æ‰‹åŠ¨é‡Šæ”¾é”ï¼Œå¦‚æœæ²¡æœ‰ä¸»åŠ¨é‡Šæ”¾é”ï¼Œå°±æœ‰å¯èƒ½å¯¼è‡´å‡ºç°æ­»é”ç°è±¡ã€‚éœ€è¦lock()å’Œunlock()æ–¹æ³•é…åˆtry/finallyè¯­å¥å—æ¥å®Œæˆï¼Œ |
| 3.çµæ´»æ€§         | é”çš„èŒƒå›´æ˜¯æ•´ä¸ªæ–¹æ³•æˆ–synchronizedå—éƒ¨åˆ†                       | Lockå› ä¸ºæ˜¯æ–¹æ³•è°ƒç”¨ï¼Œå¯ä»¥è·¨æ–¹æ³•ï¼Œçµæ´»æ€§æ›´å¤§                   |
| 4.ç­‰å¾…å¯ä¸­æ–­     | ä¸å¯ä¸­æ–­ï¼Œé™¤éæŠ›å‡ºå¼‚å¸¸(é‡Šæ”¾é”æ–¹å¼ï¼š    1.ä»£ç æ‰§è¡Œå®Œï¼Œæ­£å¸¸é‡Šæ”¾é”ï¼›    2.æŠ›å‡ºå¼‚å¸¸ï¼Œç”±JVMé€€å‡ºç­‰å¾…) | æŒæœ‰é”çš„çº¿ç¨‹é•¿æœŸä¸é‡Šæ”¾çš„æ—¶å€™ï¼Œæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹å¯ä»¥é€‰æ‹©æ”¾å¼ƒç­‰å¾…,(æ–¹æ³•ï¼š   1.è®¾ç½®è¶…æ—¶æ–¹æ³• tryLock(long timeout, TimeUnit unit)ï¼Œæ—¶é—´è¿‡äº†å°±æ”¾å¼ƒç­‰å¾…ï¼›   2.lockInterruptibly()æ”¾ä»£ç å—ä¸­ï¼Œè°ƒç”¨interrupt()æ–¹æ³•å¯ä¸­æ–­ï¼Œè€Œsynchronizedä¸è¡Œ) |
| 5.æ˜¯å¦å…¬å¹³é”     | éå…¬å¹³é”                                                     | ä¸¤è€…éƒ½å¯ä»¥ï¼Œé»˜è®¤å…¬å¹³é”ï¼Œæ„é€ å™¨å¯ä»¥ä¼ å…¥booleanå€¼ï¼Œtrueä¸ºå…¬å¹³é”ï¼Œfalseä¸ºéå…¬å¹³é”ï¼Œ |
| 6.æ¡ä»¶Condition  |                                                              | é€šè¿‡å¤šæ¬¡newConditionå¯ä»¥è·å¾—å¤šä¸ªConditionå¯¹è±¡,å¯ä»¥ç®€å•çš„å®ç°æ¯”è¾ƒå¤æ‚çš„çº¿ç¨‹åŒæ­¥çš„åŠŸèƒ½. |
| 7.æä¾›çš„é«˜çº§åŠŸèƒ½ |                                                              | æä¾›å¾ˆå¤šæ–¹æ³•ç”¨æ¥ç›‘å¬å½“å‰é”çš„ä¿¡æ¯ï¼Œå¦‚ï¼š` getHoldCount()  getQueueLength() isFair() isHeldByCurrentThread() isLocked()` |

## CASæ˜¯ä»€ä¹ˆã€CASçš„ABAé—®é¢˜å¦‚ä½•è§£å†³ - ç™¾åº¦ ç¾å›¢

**CASçš„å«ä¹‰**

CASæ˜¯compare and swapçš„ç¼©å†™ï¼Œå³æˆ‘ä»¬æ‰€è¯´çš„æ¯”è¾ƒäº¤æ¢ã€‚CASæœºåˆ¶ä¸­ä½¿ç”¨äº†3ä¸ªåŸºæœ¬æ“ä½œæ•°ï¼šå†…å­˜åœ°å€Vï¼Œæ—§çš„é¢„æœŸå€¼Aï¼Œéœ€è¦æ›¿æ¢çš„å€¼Bã€‚å½“éœ€è¦æ›´æ–°ä¸€ä¸ªå˜é‡çš„å€¼çš„æ—¶å€™ï¼Œåªæœ‰å½“å˜é‡çš„é¢„æœŸå€¼Aå’Œå†…å­˜åœ°å€Vä¸­çš„å®é™…å€¼ç›¸åŒçš„æ—¶å€™ï¼Œæ‰ä¼šæŠŠå†…å­˜åœ°å€Vå¯¹åº”çš„å€¼æ›¿æ¢æˆBã€‚

æˆ‘ä»¬å¯ä»¥æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

1ã€åœ¨å†…å­˜åœ°å€Vå½“ä¸­ï¼Œå­˜å‚¨ç€å€¼ä¸º10çš„å˜é‡

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827140049889.png)

2ã€æ­¤æ—¶çº¿ç¨‹1æƒ³è¦æŠŠå˜é‡çš„å€¼å¢åŠ 1ï¼Œå¯¹äºçº¿ç¨‹1è€Œè¨€ï¼Œå®ƒæ—§çš„é¢„æœŸå€¼A=10ï¼Œéœ€è¦æ›¿æ¢çš„æœ€æ–°å€¼B=11ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827140605477.png)

3ã€åœ¨çº¿ç¨‹1è¦æäº¤æ›´æ–°ä¹‹å‰ï¼Œå¦å¤–ä¸€ä¸ªçº¿ç¨‹2æŠ¢å…ˆä¸€æ­¥ï¼Œå°†å†…å­˜åœ°å€Vä¸­çš„å€¼æ›´æ–°æˆäº†11ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827140859784.png)

4ã€çº¿ç¨‹1å¼€å§‹æäº¤æ›´æ–°çš„æ—¶å€™ï¼ŒæŒ‰ç…§CASæœºåˆ¶ï¼Œé¦–å…ˆè¿›è¡ŒAçš„å€¼ä¸å†…å­˜åœ°å€Vä¸­çš„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå‘ç°Aä¸ç­‰äºVä¸­çš„å®é™…å€¼ï¼Œäºæ˜¯æäº¤å¤±è´¥ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827141045219.png)

5.çº¿ç¨‹1é‡æ–°è·å–å†…å­˜åœ°å€Vçš„å½“å‰å€¼ï¼Œå¹¶é‡æ–°è®¡ç®—æƒ³è¦ä¿®æ”¹çš„å€¼ã€‚åœ¨ç°åœ¨è€Œè¨€ï¼Œçº¿ç¨‹1æ—§çš„é¢„æœŸå€¼A=11ï¼ŒB=12.è¿™ä¸ªé‡æ–°å°è¯•çš„è¿‡ç¨‹è¢«ç§°ä¸º**è‡ªæ—‹**ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827141148405.png)

6ã€è¿™ä¸€æ¬¡æ¯”è¾ƒå¹¸è¿ï¼Œæ²¡æœ‰å…¶ä»–çº¿ç¨‹æ”¹å˜è¯¥å˜é‡çš„å€¼ï¼Œæ‰€ä»¥çº¿ç¨‹1è¿›è¡ŒCASæœºåˆ¶ï¼Œæ¯”è¾ƒæ—§çš„é¢„æœŸå€¼Aä¸å†…å­˜åœ°å€Vä¸­çš„å€¼ï¼Œå‘ç°ç›¸åŒï¼Œæ­¤æ—¶å¯ä»¥æ›¿æ¢ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827141237335.png)

7ã€çº¿ç¨‹1è¿›è¡Œæ›¿æ¢ï¼ŒæŠŠåœ°å€Vçš„å€¼æ›¿æ¢æˆBï¼Œä¹Ÿå°±æ˜¯12ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/2019082714142138.png)

ä»æ€æƒ³ä¸Šæ¥çœ‹ï¼Œsynchronizedå±äºæ‚²è§‚é”ï¼Œæ‚²è§‚çš„è®¤ä¸ºç¨‹åºä¸­çš„å¹¶å‘é—®é¢˜ååˆ†ä¸¥é‡ï¼Œæ‰€ä»¥ä¸¥é˜²æ­»å®ˆï¼Œåªè®©ä¸€ä¸ªçº¿ç¨‹æ“ä½œè¯¥ä»£ç å—ã€‚è€ŒCASå±äºä¹è§‚é”ï¼Œä¹è§‚åœ°è®¤ä¸ºç¨‹åºä¸­çš„å¹¶å‘é—®é¢˜å¹¶ä¸é‚£ä¹ˆä¸¥é‡ï¼Œæ‰€ä»¥è®©çº¿ç¨‹ä¸æ–­çš„å»å°è¯•æ›´æ–°ã€‚

åœ¨javaä¸­é™¤äº†ä¸Šé¢æåˆ°çš„Atomicæ“ä½œç±»ï¼Œä»¥åŠLockç³»åˆ—ç±»çš„åº•å±‚å®ç°ï¼Œç”šè‡³åœ¨jdk1.6ä»¥ä¸Šï¼Œåœ¨synchronizedè½¬å˜ä¸ºé‡é‡çº§é”ä¹‹å‰ï¼Œä¹Ÿä¼šé‡‡ç”¨CASæœºåˆ¶ã€‚

CASçš„ä¼˜ç‚¹è‡ªç„¶æ˜¯åœ¨å¹¶å‘é—®é¢˜ä¸ä¸¥é‡çš„æ—¶å€™æ€§èƒ½æ¯”synchronizedè¦å¿«ï¼Œç¼ºç‚¹ä¹Ÿæœ‰ã€‚

**CASçš„é—®é¢˜**

1ã€CASå®¹æ˜“é€ æˆABAé—®é¢˜ã€‚ä¸€ä¸ªçº¿ç¨‹aå°†æ•°å€¼æ”¹æˆäº†bï¼Œæ¥ç€åˆæ”¹æˆäº†aï¼Œæ­¤æ—¶CASè®¤ä¸ºæ˜¯æ²¡æœ‰å˜åŒ–ï¼Œå…¶å®æ˜¯å·²ç»å˜åŒ–è¿‡äº†ï¼Œè€Œè¿™ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆå¯ä»¥ä½¿ç”¨ç‰ˆæœ¬å·æ ‡è¯†ï¼Œæ¯æ“ä½œä¸€æ¬¡versionåŠ 1ã€‚åœ¨java5ä¸­ï¼Œå·²ç»æä¾›äº†AtomicStampedReferenceæ¥è§£å†³é—®é¢˜ã€‚

2ã€CPUå¼€é”€è¿‡å¤§ã€‚åœ¨å¹¶å‘é‡æ¯”è¾ƒé«˜çš„æ—¶å€™ï¼Œå¦‚æœè®¸å¤šçº¿ç¨‹éƒ½å°è¯•å»æ›´æ–°ä¸€ä¸ªå˜é‡çš„å€¼ï¼Œå´åˆä¸€ç›´æ¯”è¾ƒå¤±è´¥ï¼Œå¯¼è‡´æäº¤å¤±è´¥ï¼Œäº§ç”Ÿè‡ªæ—‹ï¼Œå¾ªç¯å¾€å¤ï¼Œä¼šå¯¹CPUé€ æˆå¾ˆå¤§çš„å‹åŠ›å’Œå¼€é”€ã€‚

3ã€ä¸èƒ½ç¡®ä¿ä»£ç å—çš„åŸå­æ€§ï¼ˆæ³¨æ„æ˜¯ä»£ç å—ï¼‰ã€‚CASæœºåˆ¶æ‰€ç¡®ä¿çš„æ˜¯ä¸€ä¸ªå˜é‡çš„åŸå­æ€§æ“ä½œï¼Œè€Œä¸èƒ½ä¿è¯æ•´ä¸ªä»£ç å—çš„åŸå­æ€§ï¼Œæ¯”å¦‚éœ€è¦ä¿è¯3ä¸ªå˜é‡å…±åŒè¿›è¡ŒåŸå­æ€§çš„æ›´æ–°ï¼Œå°±ä¸å¾—ä¸ä½¿ç”¨synchronizedæˆ–è€…lockäº†ã€‚

**ABAé—®é¢˜ï¼š**

1ã€å‡è®¾å†…å­˜ä¸­æœ‰ä¸€ä¸ªå€¼ä¸ºAçš„å˜é‡ï¼Œå­˜å‚¨åœ¨å†…å­˜åœ°å€Vä¸­ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827155232482.png)

2ã€æ­¤æ—¶æœ‰ä¸‰ä¸ªçº¿ç¨‹æƒ³è¦ä½¿ç”¨CASçš„æ–¹å¼æ›´æ–°è¿™ä¸ªå˜é‡çš„å€¼ï¼Œæ¯ä¸ªçº¿ç¨‹çš„æ‰§è¡Œæ—¶é—´æœ‰ç•¥å¾®åå·®ã€‚çº¿ç¨‹1å’Œçº¿ç¨‹2å·²ç»è·å–å½“å‰å€¼ï¼Œçº¿ç¨‹3è¿˜æœªè·å–å½“å‰å€¼ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827155344742.png)

3ã€æ¥ä¸‹æ¥ï¼Œçº¿ç¨‹1å…ˆä¸€æ­¥æ‰§è¡ŒæˆåŠŸï¼ŒæŠŠå½“å‰å€¼æˆåŠŸä»Aæ›´æ–°ä¸ºBï¼›åŒæ—¶çº¿ç¨‹2å› æŸç§åŸå› é˜»å¡ä½ï¼Œæ²¡æœ‰åšæ›´æ–°æ“ä½œï¼Œæ­¤æ—¶çº¿ç¨‹3åœ¨çº¿ç¨‹1æ›´æ–°ä¹‹åï¼Œè·å–äº†å½“å‰å€¼Bã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827155557492.png)

4ã€åœ¨ä¹‹åï¼Œçº¿ç¨‹2ä»ç„¶å¤„äºé˜»å¡çŠ¶æ€ï¼Œçº¿ç¨‹3ç»§ç»­æ‰§è¡Œï¼ŒæˆåŠŸæŠŠå½“å‰å€¼ä»Bæ›´æ–°æˆAã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827155757283.png)

5ã€æœ€åï¼Œçº¿ç¨‹2ç»ˆäºæ¢å¤äº†è¿è¡ŒçŠ¶æ€ï¼Œç”±äºé˜»å¡ä¹‹å‰å·²ç»è·å¾—åˆ°äº†â€å½“å‰å€¼Aâ€œï¼Œå¹¶ä¸”ç»è¿‡compareæ£€æµ‹ï¼Œå†…å­˜åœ°å€Vä¸­çš„å®é™…å€¼ä¹Ÿæ˜¯Aï¼Œæ‰€ä»¥æˆåŠŸæŠŠå˜é‡Açš„å€¼æ›´æ–°ä¸ºBã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827160001628.png)

çœ‹èµ·æ¥è¿™ä¸ªä¾‹å­æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œä½†å¦‚æœç»“åˆå®é™…ï¼Œå°±å¯ä»¥å‘ç°å®ƒçš„é—®é¢˜æ‰€ï¼šæˆ‘ä»¬å‡è®¾ä¸€ä¸ªå–æ¬¾æœºçš„ä¾‹å­ã€‚å‡å¦‚æœ‰ä¸€ä¸ªéµå¾ªCASæœºåˆ¶çš„å–æ¬¾æœºã€‚å°è‚–æœ‰100å…ƒå­˜æ¬¾ï¼Œéœ€è¦æå–50å…ƒã€‚ä½†ç”±äºå–æ¬¾æœºç¡¬ä»¶å‡ºç°äº†é—®é¢˜ï¼Œå¯¼è‡´å–æ¬¾æ“ä½œåŒæ—¶æäº¤äº†ä¸¤éï¼Œå¼€å¯äº†ä¸¤ä¸ªçº¿ç¨‹ï¼Œä¸¤ä¸ªçº¿ç¨‹éƒ½æ˜¯è·å–å½“å‰å€¼100å…ƒï¼Œè¦æ›´æ–°æˆ50å…ƒã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œåº”è¯¥ä¸€ä¸ªçº¿ç¨‹æ›´æ–°æˆåŠŸï¼Œä¸€ä¸ªçº¿ç¨‹æ›´æ–°å¤±è´¥ï¼Œå°è‚–çš„å­˜æ¬¾åªæ‰£é™¤ä¸€æ¬¡ï¼Œä½™é¢ä¸º50ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827160504951.png)

çº¿ç¨‹1é¦–å…ˆæ‰§è¡ŒæˆåŠŸï¼ŒæŠŠä½™é¢100æ›´æ–°ä¸º50ï¼ŒåŒæ—¶çº¿ç¨‹2ç”±äºæŸç§åŸå› é™·å…¥äº†é˜»å¡çŠ¶æ€ï¼Œè¿™æ—¶å€™ï¼Œå°è‚–çš„å¦ˆå¦ˆæ±‡æ¬¾ç»™äº†å°è‚–50å…ƒã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827160654670.png)

çº¿ç¨‹2ä»ç„¶æ˜¯é˜»å¡çŠ¶æ€ï¼Œçº¿ç¨‹3æ­¤æ—¶æ‰§è¡ŒæˆåŠŸï¼ŒæŠŠä½™é¢ä»50æ”¹æˆäº†100.

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827160832629.png)

è¿™æ—¶å€™ï¼Œçº¿ç¨‹2æ¢å¤è¿è¡Œï¼Œç”±äºä¹‹å‰é˜»å¡çš„æ—¶å€™è·å¾—äº†â€å½“å‰å€¼â€œ100ï¼Œå¹¶ä¸”ç»è¿‡compareæ£€æµ‹ï¼Œæ­¤æ—¶å­˜æ¬¾ä¹Ÿçš„ç¡®æ˜¯100å…ƒï¼Œæ‰€ä»¥æˆåŠŸæŠŠå˜é‡å€¼ä»100æ›´æ–°æˆ50ã€‚

![20190827160958866](img/20190827160958866.png)

åŸæœ¬çº¿ç¨‹2åº”å½“æäº¤å¤±è´¥ï¼Œå°è‚–çš„æ­£ç¡®ä½™é¢åº”è¯¥ä¿æŒ100å…ƒï¼Œç»“æœç”±äºABAé—®é¢˜ï¼Œæœ€ç»ˆå°è‚–çš„ä½™é¢ä¸º50å…ƒã€‚

**æ·»åŠ ç‰ˆæœ¬å·è§£å†³ABAé—®é¢˜**

çœŸæ­£è¦åšåˆ°ä¸¥è°¨çš„CASæœºåˆ¶ï¼Œæˆ‘ä»¬åœ¨compareé˜¶æ®µä¸ä»…éœ€è¦æ¯”è¾ƒå†…å­˜åœ°å€Vä¸­çš„å€¼æ˜¯å¦å’Œæ—§çš„æœŸæœ›å€¼Aç›¸åŒï¼Œè¿˜éœ€è¦æ¯”è¾ƒå˜é‡çš„ç‰ˆæœ¬å·æ˜¯å¦ä¸€è‡´ã€‚

æˆ‘ä»¬ä»ç„¶ä»¥åˆšæ‰çš„ä¾‹å­æ¥è¯´æ˜ï¼Œå‡è®¾åœ°å€Vä¸­å­˜å‚¨ç€å˜é‡å€¼Aï¼Œå½“å‰ç‰ˆæœ¬å·æ˜¯01ï¼Œçº¿ç¨‹1è·å–äº†å½“å‰å€¼Aå’Œç‰ˆæœ¬å·01ï¼Œæƒ³è¦æ›´æ–°ä¸ºBï¼Œæ­¤æ—¶çº¿ç¨‹1é™·å…¥äº†é˜»å¡çŠ¶æ€ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827161431185.png)

è¿™æ—¶å€™ï¼Œå†…å­˜åœ°å€Vä¸­çš„å˜é‡è¿›è¡Œäº†å¤šæ¬¡æ”¹å˜ï¼Œç‰ˆæœ¬å·æå‡åˆ°03ï¼Œä½†æ˜¯å˜é‡å€¼ä»ç„¶æ˜¯Aã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827161556496.png)

éšåï¼Œçº¿ç¨‹1æ¢å¤è¿è¡Œï¼Œè¿›è¡Œcompareæ“ä½œã€‚é¦–å…ˆç»è¿‡æ¯”è¾ƒï¼Œå†…å­˜åœ°å€Vä¸­çš„å€¼ä¸å½“å‰å€¼Aç›¸åŒï¼Œä½†æ˜¯ç‰ˆæœ¬å·ä¸ç›¸åŒï¼Œæ‰€ä»¥è¿™ä¸€æ¬¡æ›´æ–°å¤±è´¥ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20190827161719185.png)

åœ¨Javaä¸­ï¼ŒAtomicStampedReferenceç±»å°±å®ç°äº†ç”¨ç‰ˆæœ¬å·åšæ¯”è¾ƒçš„CASæœºåˆ¶ã€‚

æ€»ç»“ï¼š**å½“ä¸€ä¸ªå€¼ä»Aæ›´æ–°ä¸ºBï¼Œå†ä»Bæ›´æ–°ä¸ºAï¼Œæ™®é€šCASæœºåˆ¶ä¼šè¯¯åˆ¤é€šè¿‡æ£€æµ‹ã€‚è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ç‰ˆæœ¬å·ï¼Œé€šè¿‡æ¯”è¾ƒå€¼å’Œç‰ˆæœ¬å·æ‰åˆ¤æ–­æ˜¯å¦å¯ä»¥æ›¿æ¢ã€‚**



## è¯·è°ˆä¸€ä¸‹AQSï¼Œä¸ºä»€ä¹ˆAQSçš„åº•å±‚æ˜¯CAS + volatile- ç™¾åº¦

AQSçš„å…¨ç§°ä¸ºï¼ˆAbstractQueuedSynchronizerï¼ŒæŠ½è±¡é˜Ÿåˆ—åŒæ­¥å™¨ï¼‰ï¼Œè¿™ä¸ªç±»åœ¨java.util.concurrent.locksåŒ…ä¸‹é¢ã€‚AQSæ˜¯ä¸€ä¸ªç”¨æ¥æ„å»ºé”å’ŒåŒæ­¥å™¨çš„æ¡†æ¶ï¼Œæ¯”å¦‚ReentrantLockï¼ŒSemaphoreï¼ŒReentrantReadWriteLockï¼ŒSynchronousQueueï¼ŒFutureTaskç­‰ç­‰çš†æ˜¯åŸºäºAQSçš„ã€‚

AQSæ˜¯åŸºäºvolatile+caså®ç°çš„ï¼Œå¦‚æœéœ€è¦çº¿ç¨‹é˜»å¡ç­‰å¾…ï¼Œå”¤é†’æœºåˆ¶ï¼Œåˆ™ä½¿ç”¨LockSupportçš„park()å’Œunpark()æ–¹æ³•æŒ‚èµ·ã€å”¤é†’çº¿ç¨‹ã€‚

```java
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {
    // ç»§æ‰¿è‡ªAbstractOwnableSynchronizer
    /**
     * The current owner of exclusive mode synchronization.
     */
    private transient Thread exclusiveOwnerThread;
    
    /**
     * Head of the wait queue, lazily initialized.  Except for
     * initialization, it is modified only via method setHead.  Note:
     * If head exists, its waitStatus is guaranteed not to be
     * CANCELLED.
     */
    private transient volatile Node head;

    /**
     * Tail of the wait queue, lazily initialized.  Modified only via
     * method enq to add new wait node.
     */
    private transient volatile Node tail;

    /**
     * The synchronization state.
     */
    private volatile int state;
    
    /**
     * Wait queue node class.
     *
     * <p>The wait queue is a variant of a "CLH" (Craig, Landin, and
     * Hagersten) lock queue. CLH locks are normally used for
     * spinlocks.  We instead use them for blocking synchronizers, but
     * use the same basic tactic of holding some of the control
     * information about a thread in the predecessor of its node.  A
     * "status" field in each node keeps track of whether a thread
     * should block.  A node is signalled when its predecessor
     * releases.  Each node of the queue otherwise serves as a
     * specific-notification-style monitor holding a single waiting
     * thread. The status field does NOT control whether threads are
     * granted locks etc though.  A thread may try to acquire if it is
     * first in the queue. But being first does not guarantee success;
     * it only gives the right to contend.  So the currently released
     * contender thread may need to rewait.
     *
     * <p>To enqueue into a CLH lock, you atomically splice it in as new
     * tail. To dequeue, you just set the head field.
     * <pre>
     *      +------+  prev +-----+       +-----+
     * head |      | <---- |     | <---- |     |  tail
     *      +------+       +-----+       +-----+
     * </pre>
     *
     * <p>Insertion into a CLH queue requires only a single atomic
     * operation on "tail", so there is a simple atomic point of
     * demarcation from unqueued to queued. Similarly, dequeuing
     * involves only updating the "head". However, it takes a bit
     * more work for nodes to determine who their successors are,
     * in part to deal with possible cancellation due to timeouts
     * and interrupts.
     *
     * <p>The "prev" links (not used in original CLH locks), are mainly
     * needed to handle cancellation. If a node is cancelled, its
     * successor is (normally) relinked to a non-cancelled
     * predecessor. For explanation of similar mechanics in the case
     * of spin locks, see the papers by Scott and Scherer at
     * http://www.cs.rochester.edu/u/scott/synchronization/
     *
     * <p>We also use "next" links to implement blocking mechanics.
     * The thread id for each node is kept in its own node, so a
     * predecessor signals the next node to wake up by traversing
     * next link to determine which thread it is.  Determination of
     * successor must avoid races with newly queued nodes to set
     * the "next" fields of their predecessors.  This is solved
     * when necessary by checking backwards from the atomically
     * updated "tail" when a node's successor appears to be null.
     * (Or, said differently, the next-links are an optimization
     * so that we don't usually need a backward scan.)
     *
     * <p>Cancellation introduces some conservatism to the basic
     * algorithms.  Since we must poll for cancellation of other
     * nodes, we can miss noticing whether a cancelled node is
     * ahead or behind us. This is dealt with by always unparking
     * successors upon cancellation, allowing them to stabilize on
     * a new predecessor, unless we can identify an uncancelled
     * predecessor who will carry this responsibility.
     *
     * <p>CLH queues need a dummy header node to get started. But
     * we don't create them on construction, because it would be wasted
     * effort if there is never contention. Instead, the node
     * is constructed and head and tail pointers are set upon first
     * contention.
     *
     * <p>Threads waiting on Conditions use the same nodes, but
     * use an additional link. Conditions only need to link nodes
     * in simple (non-concurrent) linked queues because they are
     * only accessed when exclusively held.  Upon await, a node is
     * inserted into a condition queue.  Upon signal, the node is
     * transferred to the main queue.  A special value of status
     * field is used to mark which queue a node is on.
     *
     * <p>Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill
     * Scherer and Michael Scott, along with members of JSR-166
     * expert group, for helpful ideas, discussions, and critiques
     * on the design of this class.
     */
    static final class Node {
        /** Marker to indicate a node is waiting in shared mode */
        static final Node SHARED = new Node();
        /** Marker to indicate a node is waiting in exclusive mode */
        static final Node EXCLUSIVE = null;

        /** waitStatus value to indicate thread has cancelled */
        static final int CANCELLED =  1;
        /** waitStatus value to indicate successor's thread needs unparking */
        static final int SIGNAL    = -1;
        /** waitStatus value to indicate thread is waiting on condition */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;

        /**
         * Status field, taking on only the values:
         *   SIGNAL:     The successor of this node is (or will soon be)
         *               blocked (via park), so the current node must
         *               unpark its successor when it releases or
         *               cancels. To avoid races, acquire methods must
         *               first indicate they need a signal,
         *               then retry the atomic acquire, and then,
         *               on failure, block.
         *   CANCELLED:  This node is cancelled due to timeout or interrupt.
         *               Nodes never leave this state. In particular,
         *               a thread with cancelled node never again blocks.
         *   CONDITION:  This node is currently on a condition queue.
         *               It will not be used as a sync queue node
         *               until transferred, at which time the status
         *               will be set to 0. (Use of this value here has
         *               nothing to do with the other uses of the
         *               field, but simplifies mechanics.)
         *   PROPAGATE:  A releaseShared should be propagated to other
         *               nodes. This is set (for head node only) in
         *               doReleaseShared to ensure propagation
         *               continues, even if other operations have
         *               since intervened.
         *   0:          None of the above
         *
         * The values are arranged numerically to simplify use.
         * Non-negative values mean that a node doesn't need to
         * signal. So, most code doesn't need to check for particular
         * values, just for sign.
         *
         * The field is initialized to 0 for normal sync nodes, and
         * CONDITION for condition nodes.  It is modified using CAS
         * (or when possible, unconditional volatile writes).
         */
        volatile int waitStatus;

        /**
         * Link to predecessor node that current node/thread relies on
         * for checking waitStatus. Assigned during enqueuing, and nulled
         * out (for sake of GC) only upon dequeuing.  Also, upon
         * cancellation of a predecessor, we short-circuit while
         * finding a non-cancelled one, which will always exist
         * because the head node is never cancelled: A node becomes
         * head only as a result of successful acquire. A
         * cancelled thread never succeeds in acquiring, and a thread only
         * cancels itself, not any other node.
         */
        volatile Node prev;

        /**
         * Link to the successor node that the current node/thread
         * unparks upon release. Assigned during enqueuing, adjusted
         * when bypassing cancelled predecessors, and nulled out (for
         * sake of GC) when dequeued.  The enq operation does not
         * assign next field of a predecessor until after attachment,
         * so seeing a null next field does not necessarily mean that
         * node is at end of queue. However, if a next field appears
         * to be null, we can scan prev's from the tail to
         * double-check.  The next field of cancelled nodes is set to
         * point to the node itself instead of null, to make life
         * easier for isOnSyncQueue.
         */
        volatile Node next;

        /**
         * The thread that enqueued this node.  Initialized on
         * construction and nulled out after use.
         */
        volatile Thread thread;

        /**
         * Link to next node waiting on condition, or the special
         * value SHARED.  Because condition queues are accessed only
         * when holding in exclusive mode, we just need a simple
         * linked queue to hold nodes while they are waiting on
         * conditions. They are then transferred to the queue to
         * re-acquire. And because conditions can only be exclusive,
         * we save a field by using special value to indicate shared
         * mode.
         */
        Node nextWaiter;
    }
    
    public class ConditionObject implements Condition, java.io.Serializable {
    	//æ¡ä»¶é˜Ÿåˆ—;Node å¤ç”¨äº†AQSä¸­å®šä¹‰çš„Node
        private transient Node firstWaiter;
        private transient Node lastWaiter;
    }
}
```

- AQSä½¿ç”¨æˆå‘˜å˜é‡exclusiveOwnerThreadæ¥è®°å½•å æœ‰è¯¥é”çš„çº¿ç¨‹
- ä½¿ç”¨æˆå‘˜å˜é‡stateæ¥è¡¨ç¤ºåŒæ­¥çŠ¶æ€ï¼Œé€šè¿‡CASå®Œæˆå¯¹stateå€¼çš„ä¿®æ”¹
- é€šè¿‡å†…ç½®çš„CLHé˜Ÿåˆ—æ¥å®Œæˆèµ„æºè·å–çš„æ’é˜Ÿå·¥ä½œï¼ˆé˜Ÿåˆ—ä¸­çš„å…ƒç´ å°±æ˜¯åŒ…è£…äº†çº¿ç¨‹çš„Nodeï¼‰ï¼ŒåŒæ­¥é˜Ÿåˆ—ä¸­é¦–èŠ‚ç‚¹æ˜¯è·å–åˆ°é”çš„èŠ‚ç‚¹ï¼Œå®ƒåœ¨é‡Šæ”¾é”çš„æ—¶ä¼šå”¤é†’åç»§èŠ‚ç‚¹ï¼Œåç»§èŠ‚ç‚¹è·å–åˆ°é”çš„æ—¶å€™ï¼Œä¼šæŠŠè‡ªå·±è®¾ä¸ºé¦–èŠ‚ç‚¹
- åœ¨AQSè¿˜å­˜ä¸€ä¸ªConditionObjectçš„å†…éƒ¨ç±»ï¼Œå®ƒçš„ä½¿ç”¨æœºåˆ¶å’ŒObject.waitã€notifyç±»ä¼¼
- AQSä¸­æä¾›å‡ ä¸ªé‡è¦çš„æ–¹æ³•:
  - tryAcquireè·å–é”
  - addWaiterè·å–é”å¤±è´¥åæŠŠå½“å‰çº¿ç¨‹æ”¾å…¥é˜Ÿåˆ—ä¸­
  - acquireQueuedä½¿çº¿ç¨‹åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­è·å–èµ„æºï¼Œä¸€ç›´è·å–åˆ°èµ„æºåæ‰è¿”å›
  - tryReleaseè§£é”

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

```java
protected boolean tryAcquire(int arg);//å°è¯•ç‹¬å æ€§åŠ é”
protected boolean tryRelease(int arg);//å¯¹åº”tryAcquireé‡Šæ”¾é”
protected int tryAcquireShared(int arg);//å°è¯•å…±äº«æ€§åŠ é”
protected boolean tryReleaseShared(int arg);//å¯¹åº”tryAcquireSharedé‡Šæ”¾é”
protected boolean isHeldExclusively();//è¯¥çº¿ç¨‹æ˜¯å¦æ­£åœ¨ç‹¬å èµ„æºï¼Œåªæœ‰ç”¨åˆ°conditionæ‰éœ€è¦å–å®ç°å®ƒ
```

**ä¸ºä»€ä¹ˆAQSçš„åº•å±‚æ˜¯CAS + volatileï¼Ÿ**

- volatileä¿è¯äº†ä»£ç çš„å¯è§æ€§ï¼Œä¾‹å¦‚åŠ é”çŠ¶æ€éœ€è¦ä¿è¯å¯¹å…¶ä»–çº¿ç¨‹æ˜¯å¯è§çš„
- casæœºåˆ¶ä¿è¯å˜é‡æ“ä½œæ˜¯åŸå­æ€§çš„ï¼Œä¿è¯çº¿ç¨‹çš„å®‰å…¨



## è¯·è°ˆä¸€ä¸‹ä½ å¯¹volatileçš„ç†è§£ï¼Œvolatileçš„å¯è§æ€§å’Œç¦æ­¢æŒ‡ä»¤é‡æ’åºæ˜¯å¦‚ä½•å®ç°çš„ - ç¾å›¢ é˜¿é‡Œ

**volatile**

Javaä¸­æä¾›äº†ä¸€ä¸ªå…³é”®å­—volatileï¼Œè¿™ä¸ªå…³é”®å­—èƒ½å¤Ÿä¿è¯çº¿ç¨‹å¯è§æ€§å’Œç¦æ­¢æŒ‡ä»¤é‡æ’åº

**volatileä¿è¯å¯è§æ€§**

volatileå…¶å®å°±æ˜¯åˆ©ç”¨äº†ç¼“å­˜ä¸€è‡´æ€§åè®®ï¼Œä¸€æ—¦æŸä¸ªå˜é‡è¢«volatileä¿®é¥°ï¼Œé‚£ä¹ˆä¸€æ—¦è¿™ä¸ªå˜é‡è¢«çº¿ç¨‹ä¿®æ”¹ï¼Œå…¶ä»–çº¿ç¨‹é”ä¿æŒçš„è¯¥å˜é‡çš„ç¼“å­˜å°±ä¼šå¤±æ•ˆï¼Œéœ€è¦ä»å†…å­˜ä¸­è·å–æœ€æ–°å€¼ã€‚å¦‚ä¸‹æ¡ˆä¾‹ï¼š

```java
public class TestVolatile {
    private static /*volatile*/ boolean flag = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (true) {
                if (flag) {
                    break;
                }
            }
            System.out.println("m end");
        }).start();

        // 1såç”±å¦ä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹flagçš„å€¼
        Thread.sleep(1000);
        flag = true;
    }
}
```

ä¸¤ä¸ªçº¿ç¨‹å…±äº«å˜é‡flagï¼Œå…¶ä¸­ä¸€ä¸ªçº¿ç¨‹åœ¨åšæ— é™å¾ªç¯ï¼Œç›´åˆ°flagä¸ºtrueæ—¶è·³å‡ºå¾ªç¯ï¼Œ1såå¦ä¸€ä¸ªçº¿ç¨‹å°†flagæ”¹ä¸ºtrueï¼Œå¦‚æœflagä¸åŠ volatileä¿®é¥°ï¼Œæ‰§è¡Œç¨‹åºä¼šå‘ç°ç¨‹åºåœä¸ä¸‹æ¥ã€‚è€Œå¦‚æœç”¨volatileä¿®é¥°flagï¼Œç¨‹åºå¤§çº¦ä¼šåœ¨1såç»“æŸå¹¶æ‰“å°â€œm endâ€ã€‚

**volatileç¦æ­¢æŒ‡ä»¤é‡æ’åº**

åˆ©ç”¨volatileæ¥ç¦æ­¢æŒ‡ä»¤é‡æ’åºçš„ä¸€ä¸ªç»å…¸æ¡ˆä¾‹å°±æ˜¯åŒé‡æ£€æŸ¥é”å•ä¾‹ï¼ˆDCLï¼‰ï¼Œä»£ç å¦‚ä¸‹:

```java
class Singleton{
    private volatile static Singleton singleton;

    private Singleton(){}

    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

åŒé‡æ£€æŸ¥é”é€šè¿‡ä¸¤æ¬¡åˆ¤ç©ºä»¥åŠåŠ synchronizedé”æ¥å®ç°å•ä¾‹å¯¹è±¡çš„åˆ›å»ºï¼Œä¸ºäº†é™ä½é”çš„ç²’åº¦ï¼Œåªåœ¨åˆ›å»ºå¯¹è±¡çš„æ ¸å¿ƒä»£ç å—å¤–åŠ synchronizedã€‚çº¿ç¨‹è¿›å…¥getInstanceæ–¹æ³•åï¼Œå…ˆåˆ¤æ–­singletonæ˜¯å¦ä¸ºnullï¼Œå¦‚æœä¸ºnullï¼Œåˆ™å°è¯•è·å–é”ï¼Œå¦‚æœè·å–åˆ°äº†é”ï¼Œåˆ™è¿›å…¥synchronizedä»£ç å—ï¼Œæ­¤æ—¶ç¬¬äºŒæ¬¡åˆ¤æ–­singletonæ˜¯å¦ä¸ºnullï¼ŒåŸå› æ˜¯å¯èƒ½ä¼šæœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶è¿›å…¥äº†ç¬¬ä¸€ä¸ªifæ¡ä»¶ï¼Œç¬¬äºŒä¸ªifåˆ¤æ–­èƒ½å¤Ÿä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿåˆ›å»ºå¯¹è±¡ã€‚

å•ä¾‹æ¨¡å¼ä¸æ˜¯è¿™é‡Œé‡ç‚¹ï¼Œé‡ç‚¹æ˜¯é™æ€å˜é‡singletonå‰é¢çš„ä¿®é¥°ç¬¦ä¸ºä»€ä¹ˆä¸€å®šè¦åŠ ä¸Švolatileï¼Ÿä¸‹é¢æœ‰ä¸€ä¸ªæœ€ç®€å•çš„åˆ›å»ºå¯¹è±¡çš„ä»£ç ï¼š

![image-20210124144605771](img/image-20210124144605771.png)

ç¬¬ä¸€æ­¥newä»£è¡¨ä¸ºå¯¹è±¡åˆ†é…å†…å­˜ï¼ŒæœŸé—´ä¼šå°†æˆå‘˜å˜é‡éƒ½è®¾ä¸ºé»˜è®¤å€¼ï¼Œæˆå‘˜m=0ï¼Œæ­¤æ—¶å¯¹è±¡è¿˜å¤„äºåŠåˆå§‹åŒ–çŠ¶æ€ï¼›ç¬¬äºŒæ­¥æ˜¯æ‰§è¡Œæ„é€ æ–¹æ³•ï¼Œè¿™ä¸€æ­¥ä¼šåˆå§‹åŒ–æˆå‘˜å˜é‡ï¼Œä¸ºæˆå‘˜å˜é‡èµ‹äºˆæ­£ç¡®çš„å€¼ï¼Œæ­¤æ—¶m=8ï¼›ç¬¬ä¸‰æ­¥`astore_1`ä¼šå°†åˆ›å»ºå¥½çš„å¯¹è±¡ä¸æ ˆä¸­çš„å˜é‡tå»ºç«‹è¿æ¥ï¼Œä¹Ÿå°±æ˜¯å°†tæŒ‡å‘å¯¹è±¡åœ°å€ã€‚

è¿™ä¸ªæ—¶å€™å†çœ‹DCLä»£ç ï¼Œç»“åˆå‰é¢åˆ†æçš„ï¼Œåœ¨åˆ›å»ºSingletonå¯¹è±¡çš„è¿‡ç¨‹ä¸­ï¼ŒæŒ‡ä»¤å¯èƒ½ä¼šå‘ç”Ÿé‡æ’åºï¼Œç¬¬ä¸€æ­¥åˆ†é…å†…å­˜å¿…ç„¶å…ˆæ‰§è¡Œï¼Œä½†æ˜¯`invokespecial #3 <T.<init>>`å’Œ`astore_1`çš„æ‰§è¡Œé¡ºåºå¯èƒ½ä¼šé¢ å€’ï¼Œå¦‚æœ`astore_1`å…ˆæ‰§è¡Œï¼Œé‚£ä¹ˆåœ¨å¾ˆçŸ­çš„ä¸€æ®µæ—¶é—´å†…å˜é‡Singletonå°±ä¼šæŒ‡å‘ä¸€ä¸ªè¿˜æœªå®Œå…¨åˆå§‹åŒ–çš„åŠåˆå§‹åŒ–å¯¹è±¡ï¼Œè€Œè¿™ä¸ªåŠåˆå§‹åŒ–å¯¹è±¡æ˜¯åœ¨å†…å­˜ä¸­å®é™…å­˜åœ¨çš„ï¼Œå®ƒ!=nullï¼Œå‡å¦‚æ­¤æ—¶å¦ä¸€ä¸ªçº¿ç¨‹è¿›å…¥æ–¹æ³•åˆ¤æ–­`singleton==null`ä¸æˆç«‹ï¼Œå°±ä¼šå°†å¯¹è±¡è¿”å›ï¼Œå¦‚æœå¯¹è±¡è¢«ç”¨äºå…¶ä»–é‡è¦ç”¨é€”ï¼Œåˆ™å¯èƒ½ä¼šå¸¦æ¥ä¸¥é‡çš„é—®é¢˜ï¼Œå› æ­¤ä¸ºäº†è§„é¿æŒ‡ä»¤é‡æ’åºå¸¦æ¥çš„å°†åŠåˆå§‹åŒ–å¯¹è±¡è¿”å›çš„é—®é¢˜ï¼Œå¿…é¡»åœ¨å•ä¾‹å¯¹è±¡å‰åŠ ä¿®é¥°ç¬¦volatileã€‚

**ä¸ºä»€ä¹ˆï¼Œsynchronized ä¹Ÿæœ‰æœ‰åºæ€§çš„ç‰¹ç‚¹ï¼Œè¿˜éœ€è¦ volatile å…³é”®å­—ï¼Ÿ**

å› ä¸ºï¼Œsynchronized çš„æœ‰åºæ€§ï¼Œä¸æ˜¯ volatile çš„é˜²æ­¢æŒ‡ä»¤é‡æ’åºã€‚

é‚£å¦‚æœä¸åŠ  volatile å…³é”®å­—å¯èƒ½å¯¼è‡´çš„ç»“æœï¼Œå°±æ˜¯ç¬¬ä¸€ä¸ªçº¿ç¨‹åœ¨åˆå§‹åŒ–åˆå§‹åŒ–å¯¹è±¡ï¼Œè®¾ç½® instance æŒ‡å‘å†…å­˜åœ°å€æ—¶ã€‚ç¬¬äºŒä¸ªçº¿ç¨‹è¿›å…¥æ—¶ï¼Œæœ‰æŒ‡ä»¤é‡æ’ã€‚åœ¨åˆ¤æ–­ if (instance == null) æ—¶å°±ä¼šæœ‰å‡ºé”™çš„å¯èƒ½ï¼Œå› ä¸ºè¿™ä¼šå¯èƒ½ instance å¯èƒ½è¿˜æ²¡æœ‰åˆå§‹åŒ–æˆåŠŸã€‚

**Javaæ˜¯å¦‚ä½•ç¦æ­¢æŒ‡ä»¤é‡æ’åºçš„å‘¢ï¼Ÿ**

JVMé€šè¿‡ç»™æŒ‡ä»¤å‰ååŠ ä¸Šå†…å­˜å±éšœï¼Œå±éšœä¸¤è¾¹çš„æŒ‡ä»¤ä¸å¯ä»¥é‡æ’åºï¼Œä¿è¯æœ‰åºã€‚

**å†…å­˜å±éšœ**

**JVMå±‚é¢ï¼š**JVMè§„å®šï¼Œåœ¨å¯¹volatileä¿®é¥°çš„å†…å­˜åŒºåŸŸè¿›è¡Œè¯»å†™æ—¶ï¼Œéœ€è¦åŠ å±éšœï¼Œä¹Ÿå°±æ˜¯ä¼šåœ¨ä¸¤æ¡æŒ‡ä»¤ä¹‹é—´åŠ ä¸€å±‚ç‰¹æ®Šçš„å±éšœï¼Œé˜»æ­¢ä¸¤æ¡æŒ‡ä»¤äº¤æ¢æ‰§è¡Œé¡ºåºï¼ŒJavaä¸­çš„JSRï¼ˆJava Specification Requestsï¼‰è§„èŒƒè§„å®šçš„å†…å­˜å±éšœæœ‰ä»¥ä¸‹å››ç§ï¼š

![image-20210124145314900](img/image-20210124145314900.png)

ä¸Šé¢å‡ ç§å±éšœçš„å¤§è‡´æ„æ€å°±æ˜¯åœ¨å†™æ“ä½œæˆ–è¯»æ“ä½œå‰ååŠ ä¸Šå±éšœï¼Œç­‰å®Œå…¨æ‰§è¡Œå®Œæ¯•ä¹‹åæ‰å¯ä»¥è¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œï¼Œä¹Ÿå°±æ˜¯ä¿è¯äº†æŒ‡ä»¤å¿…é¡»æœ‰åºæ‰§è¡Œã€‚

![image-20210124145418330](img/image-20210124145418330-1611740770146.png)

è¿™é‡Œçš„å†…å­˜å±éšœåªæ˜¯Javaçš„è§„å®šï¼Œåœ¨**CPUå±‚é¢**ä¼šæä¾›ç¡¬ä»¶æ”¯æŒï¼š

![image-20210124144718262](img/image-20210124144718262.png)

![image-20210124145046243](img/image-20210124145046243.png)

![image-20210124145107018](img/image-20210124145107018.png)

ä¸åŒç‰ˆæœ¬çš„JVMå¯èƒ½ä¼šæœ‰ä¸åŒçš„å®ç°ï¼Œä¾‹å¦‚hotspotè™šæ‹Ÿæœºåˆ™æ˜¯åˆ©ç”¨CPUçš„è‡ªå¸¦æŒ‡ä»¤lockï¼ŒlockæŒ‡ä»¤ç”¨äºåœ¨å¤šå¤„ç†å™¨ä¸­æ‰§è¡ŒæŒ‡ä»¤æ—¶å¯¹å…±äº«å†…å­˜çš„ç‹¬å ä½¿ç”¨ï¼Œå®ƒçš„ä½œç”¨æ˜¯èƒ½å¤Ÿå°†å½“å‰å¤„ç†å™¨å¯¹åº”ç¼“å­˜çš„å†…å®¹åˆ·æ–°åˆ°å†…å­˜ï¼Œå¹¶ä½¿å…¶ä»–å¤„ç†å™¨å¯¹åº”çš„ç¼“å­˜å¤±æ•ˆã€‚å¦å¤–è¿˜æä¾›äº†æœ‰åºçš„æŒ‡ä»¤æ— æ³•è¶Šè¿‡è¿™ä¸ªå†…å­˜å±éšœçš„ä½œç”¨ã€‚ä¸‹å›¾æ˜¯hotspotä¸­å…³äºå†…å­˜å±éšœçš„å®ç°æºç ï¼š
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](img/20201122212115598.png)



## DCLå•ä¾‹ä¸ºä»€ä¹ˆè¦åŠ volatile - ç¾å›¢

![image-20210124144605771](img/image-20210124144605771.png)

![image-20210124144421447](img/image-20210124144421447.png)

![image-20210124144457702](img/image-20210124144457702.png)

![image-20210124144523138](img/image-20210124144523138.png)



## èŠèŠä½ å¯¹as-if-serial å’Œ happens-before è¯­ä¹‰çš„ç†è§£ - äº¬ä¸œ

### as-if-serial

`as-if-serial`è¯­ä¹‰çš„æ„æ€æ˜¯ï¼š`ä¸ç®¡æ€ä¹ˆé‡æ’åºï¼Œå•çº¿ç¨‹ç¨‹åºçš„æ‰§è¡Œç»“æœä¸èƒ½è¢«æ”¹å˜ã€‚ç¼–è¯‘å™¨ã€runtimeå’Œå¤„ç†å™¨éƒ½å¿…é¡»éµå®ˆas-if-serialè¯­ä¹‰`ã€‚æ‰€ä»¥ç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¸ä¼šå¯¹å­˜åœ¨`æ•°æ®ä¾èµ–å…³ç³»`çš„æ“ä½œåšé‡æ’åºï¼Œå› ä¸ºè¿™ç§é‡æ’åºä¼šæ”¹å˜æ‰§è¡Œç»“æœã€‚ä½†æ˜¯ï¼Œå¦‚æœæ“ä½œä¹‹é—´ä¸å­˜åœ¨æ•°æ®ä¾èµ–å…³ç³»ï¼Œè¿™äº›æ“ä½œå°±å¯èƒ½è¢«ç¼–è¯‘å™¨å’Œå¤„ç†å™¨é‡æ’åºã€‚

ä¸‹é¢è¿˜æ˜¯ä»¥ä¹¦ä¸­çš„å®ä¾‹(è®¡ç®—åœ†çš„é¢ç§¯)è¿›è¡Œè¯´æ˜ï¼š

```java
double pi  = 3.14;           // A
double r   = 1.0;            // B
double area = pi * r * r;    // C
```

ä¸Šé¢3ä¸ªæ“ä½œçš„æ•°æ®ä¾èµ–å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼š

![img](img/20190227104137511.png)

`Aå’ŒCä¹‹é—´å­˜åœ¨æ•°æ®ä¾èµ–å…³ç³»ï¼ŒåŒæ—¶Bå’ŒCä¹‹é—´ä¹Ÿå­˜åœ¨æ•°æ®ä¾èµ–å…³ç³»`ã€‚å› æ­¤åœ¨æœ€ç»ˆæ‰§è¡Œçš„æŒ‡ä»¤åºåˆ—ä¸­ï¼ŒCä¸èƒ½è¢«é‡æ’åºåˆ°Aå’ŒBçš„å‰é¢(`å› ä¸ºCæ’åˆ°Aå’ŒBçš„å‰é¢ï¼Œç¨‹åºçš„ç»“æœå°†ä¼šè¢«æ”¹å˜`)ã€‚`ä½†Aå’ŒBä¹‹é—´æ²¡æœ‰æ•°æ®ä¾èµ–å…³ç³»ï¼Œç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¯ä»¥é‡æ’åºAå’ŒBä¹‹é—´çš„æ‰§è¡Œé¡ºåº`ã€‚

è¯¥ç¨‹åºçš„ä¸¤ç§å¯èƒ½æ‰§è¡Œé¡ºåºï¼š

![img](img/20190227104236982.png)

`as-if-serialè¯­ä¹‰`æŠŠå•çº¿ç¨‹ç¨‹åºä¿æŠ¤äº†èµ·æ¥ï¼Œéµå®ˆ`as-if-serialè¯­ä¹‰`çš„ç¼–è¯‘å™¨ã€runtimeå’Œå¤„ç†å™¨å…±åŒä¸ºç¼–å†™å•çº¿ç¨‹ç¨‹åºçš„ç¨‹åºå‘˜åˆ›å»ºäº†ä¸€ä¸ªå¹»è§‰ï¼š`å•çº¿ç¨‹ç¨‹åºæ˜¯æŒ‰ç¨‹åºçš„é¡ºåºæ¥æ‰§è¡Œçš„`ã€‚

### happens-beforeåŸåˆ™

happens-beforeåŸåˆ™æ˜¯Javaå†…å­˜æ¨¡å‹ä¸­å®šä¹‰çš„ä¸¤ä¸ªæ“ä½œä¹‹é—´çš„ååºå…³ç³»ã€‚æ¯”å¦‚è¯´æ“ä½œAå…ˆè¡Œå‘ç”Ÿäºæ“ä½œBï¼Œé‚£ä¹ˆåœ¨Bæ“ä½œå‘ç”Ÿä¹‹å‰ï¼ŒAæ“ä½œäº§ç”Ÿçš„â€œå½±å“â€éƒ½ä¼šè¢«æ“ä½œBæ„ŸçŸ¥åˆ°ã€‚è¿™é‡Œçš„å½±å“æ˜¯æŒ‡ä¿®æ”¹äº†å†…å­˜ä¸­çš„å…±äº«å˜é‡ã€å‘é€äº†æ¶ˆæ¯ã€è°ƒç”¨äº†æ–¹æ³•ç­‰ã€‚

JSR-133ä½¿ç”¨happens-beforeçš„æ¦‚å¿µæ¥æŒ‡å®šä¸¤ä¸ªæ“ä½œä¹‹é—´çš„æ‰§è¡Œé¡ºåºã€‚ç”±äºè¿™ä¸¤ä¸ªæ“ä½œå¯ä»¥åœ¨ä¸€ä¸ªçº¿ç¨‹ä¹‹å†…ï¼Œä¹Ÿå¯ä»¥æ˜¯åœ¨ä¸åŒçº¿ç¨‹ä¹‹é—´ã€‚å› æ­¤ï¼Œ**JMMå¯ä»¥é€šè¿‡happens-beforeå…³ç³»å‘ç¨‹åºå‘˜æä¾›è·¨çº¿ç¨‹çš„å†…å­˜å¯è§æ€§ä¿è¯**ï¼ˆå¦‚æœAçº¿ç¨‹çš„å†™æ“ä½œaä¸Bçº¿ç¨‹çš„è¯»æ“ä½œbä¹‹é—´å­˜åœ¨happens-beforeå…³ç³»ï¼Œå°½ç®¡aæ“ä½œå’Œbæ“ä½œåœ¨ä¸åŒçš„çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œä½†JMMå‘ç¨‹åºå‘˜ä¿è¯aæ“ä½œå°†å¯¹bæ“ä½œå¯è§ï¼‰ã€‚å…·ä½“çš„å®šä¹‰ä¸ºï¼š

1ï¼‰å¦‚æœä¸€ä¸ªæ“ä½œhappens-beforeå¦ä¸€ä¸ªæ“ä½œï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªæ“ä½œçš„æ‰§è¡Œç»“æœå°†å¯¹ç¬¬äºŒä¸ªæ“ä½œå¯è§ï¼Œè€Œä¸”ç¬¬ä¸€ä¸ªæ“ä½œçš„æ‰§è¡Œé¡ºåºæ’åœ¨ç¬¬äºŒä¸ªæ“ä½œä¹‹å‰ã€‚

2ï¼‰ä¸¤ä¸ªæ“ä½œä¹‹é—´å­˜åœ¨happens-beforeå…³ç³»ï¼Œå¹¶ä¸æ„å‘³ç€Javaå¹³å°çš„å…·ä½“å®ç°å¿…é¡»è¦æŒ‰ç…§happens-beforeå…³ç³»æŒ‡å®šçš„é¡ºåºæ¥æ‰§è¡Œã€‚å¦‚æœé‡æ’åºä¹‹åçš„æ‰§è¡Œç»“æœï¼Œä¸æŒ‰happens-beforeå…³ç³»æ¥æ‰§è¡Œçš„ç»“æœä¸€è‡´ï¼Œé‚£ä¹ˆè¿™ç§é‡æ’åºå¹¶ä¸éæ³•ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼ŒJMMå…è®¸è¿™ç§é‡æ’åºï¼‰ã€‚

ä¸Šé¢çš„**1ï¼‰æ˜¯JMMå¯¹ç¨‹åºå‘˜çš„æ‰¿è¯º**ã€‚

**ä»ç¨‹åºå‘˜çš„è§’åº¦æ¥è¯´ï¼Œå¯ä»¥è¿™æ ·ç†è§£happens-beforeå…³ç³»ï¼šå¦‚æœA happens-before Bï¼Œé‚£ä¹ˆJavaå†…å­˜æ¨¡å‹å°†å‘ç¨‹åºå‘˜ä¿è¯â€”â€”Aæ“ä½œçš„ç»“æœå°†å¯¹Bå¯è§ï¼Œä¸”Açš„æ‰§è¡Œé¡ºåºæ’åœ¨Bä¹‹å‰ã€‚æ³¨æ„ï¼Œè¿™åªæ˜¯Javaå†…å­˜æ¨¡å‹å‘ç¨‹åºå‘˜åšå‡ºçš„ä¿è¯ï¼**

ä¸Šé¢çš„**2ï¼‰æ˜¯JMMå¯¹ç¼–è¯‘å™¨å’Œå¤„ç†å™¨é‡æ’åºçš„çº¦æŸåŸåˆ™**ã€‚

æ­£å¦‚å‰é¢æ‰€è¨€ï¼ŒJMMå…¶å®æ˜¯åœ¨éµå¾ªä¸€ä¸ªåŸºæœ¬åŸåˆ™ï¼šåªè¦ä¸æ”¹å˜ç¨‹åºçš„æ‰§è¡Œç»“æœï¼ˆæŒ‡çš„æ˜¯å•çº¿ç¨‹ç¨‹åºå’Œæ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºï¼‰ï¼Œç¼–è¯‘å™¨å’Œå¤„ç†å™¨æ€ä¹ˆä¼˜åŒ–éƒ½è¡Œã€‚JMMè¿™ä¹ˆåšçš„åŸå› æ˜¯ï¼šç¨‹åºå‘˜å¯¹äºè¿™ä¸¤ä¸ªæ“ä½œæ˜¯å¦çœŸçš„è¢«é‡æ’åºå¹¶ä¸å…³å¿ƒï¼Œç¨‹åºå‘˜å…³å¿ƒçš„æ˜¯ç¨‹åºæ‰§è¡Œæ—¶çš„è¯­ä¹‰ä¸èƒ½è¢«æ”¹å˜ï¼ˆå³æ‰§è¡Œç»“æœä¸èƒ½è¢«æ”¹å˜ï¼‰ã€‚å› æ­¤ï¼Œhappens-beforeå…³ç³»æœ¬è´¨ä¸Šå’Œas-if-serialè¯­ä¹‰æ˜¯ä¸€å›äº‹ã€‚

1. ç¨‹åºé¡ºåºè§„åˆ™: ä¸€ä¸ªçº¿ç¨‹ä¸­çš„æ¯ä¸ªæ“ä½œï¼Œhappens-beforeäºè¯¥çº¿ç¨‹ä¸­çš„ä»»æ„åç»­æ“ä½œï¼›
2. ç›‘è§†å™¨é”è§„åˆ™: å¯¹æ¯ä¸€ä¸ªé”çš„è§£é”ï¼Œhappens-beforeäºéšåå¯¹è¯¥é”çš„åŠ é”ï¼›
3. Volatileå˜é‡è§„åˆ™ï¼šå¯¹ä¸€ä¸ªvolatileåŸŸçš„å†™ï¼Œhappens-beforeäºä»»æ„åç»­å¯¹è¿™ä¸ªvolatileåŸŸçš„è¯»ï¼›
4. çº¿ç¨‹å¯åŠ¨è§„åˆ™ï¼šThreadçš„start()æ–¹æ³•å…ˆè¡Œå‘ç”Ÿäºè¿™ä¸ªçº¿ç¨‹çš„æ¯ä¸€ä¸ªæ“ä½œï¼›
5. çº¿ç¨‹ç»ˆæ­¢åŸåˆ™ï¼šçº¿ç¨‹çš„æ‰€æœ‰æ“ä½œéƒ½å…ˆè¡Œäºæ­¤çº¿ç¨‹çš„ç»ˆæ­¢æ£€æµ‹ï¼Œå¯ä»¥é€šè¿‡Thread.join()æ–¹æ³•ç»“æŸã€Thread.isAlive()çš„è¿”å›å€¼ç­‰æ‰‹æ®µæ£€æµ‹çº¿ç¨‹çš„ç»ˆæ­¢ï¼›
6. çº¿ç¨‹ä¸­æ–­åŸåˆ™ï¼šå¯¹çº¿ç¨‹interrupt()æ–¹æ³•çš„è°ƒç”¨å…ˆè¡Œå‘ç”Ÿäºè¢«ä¸­æ–­çº¿ç¨‹çš„ä»£ç æ£€æµ‹åˆ°ä¸­æ–­äº‹ä»¶çš„å‘ç”Ÿï¼Œå¯ä»¥é€šè¿‡Thread.interruptæ–¹æ³•æ£€æµ‹çº¿ç¨‹æ˜¯å¦ä¸­æ–­ï¼›
7. å¯¹è±¡ç»ˆç»“è§„åˆ™ï¼šä¸€ä¸ªå¯¹è±¡çš„åˆå§‹åŒ–å®Œæˆå…ˆäºå‘ç”Ÿå®ƒçš„finalize()æ–¹æ³•çš„å¼€å§‹ï¼›
8. ä¼ é€’æ€§: å¦‚æœA happens-before B, B happens-before C, é‚£ä¹ˆA happens-before Cï¼›

ä¸‹é¢ä»¥ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥è®²ä¸‹å¦‚ä½•ä½¿ç”¨è¿™äº›è§„åˆ™è¿›è¡Œæ¨è®ºï¼š

```java
double pi  = 3.14;    //A
double r   = 1.0;     //B
double area = pi * r * r; //C
```

ä¾æ—§ä»¥ä¸Šé¢è®¡ç®—åœ†é¢ç§¯çš„è¿›è¡Œæè¿°ã€‚åˆ©ç”¨ç¨‹åºé¡ºåºè§„åˆ™ï¼ˆè§„åˆ™1ï¼‰å­˜åœ¨ä¸‰ä¸ªhappens-beforeå…³ç³»ï¼š1. A happens-before Bï¼›2. B happens-before Cï¼›3. A happens-before Cã€‚è¿™é‡Œçš„ç¬¬ä¸‰ä¸ªå…³ç³»æ˜¯åˆ©ç”¨ä¼ é€’æ€§è¿›è¡Œæ¨è®ºçš„ã€‚A happens-before Bï¼Œå®šä¹‰1è¦æ±‚Aæ‰§è¡Œç»“æœå¯¹Bå¯è§ï¼Œå¹¶ä¸”Aæ“ä½œçš„æ‰§è¡Œé¡ºåºåœ¨Bæ“ä½œä¹‹å‰ï¼Œä½†ä¸æ­¤åŒæ—¶åˆ©ç”¨å®šä¹‰ä¸­çš„ç¬¬äºŒæ¡ï¼ŒAï¼ŒBæ“ä½œå½¼æ­¤ä¸å­˜åœ¨æ•°æ®ä¾èµ–æ€§ï¼Œä¸¤ä¸ªæ“ä½œçš„æ‰§è¡Œé¡ºåºå¯¹æœ€ç»ˆç»“æœéƒ½ä¸ä¼šäº§ç”Ÿå½±å“ï¼Œåœ¨ä¸æ”¹å˜æœ€ç»ˆç»“æœçš„å‰æä¸‹ï¼Œå…è®¸Aï¼ŒBä¸¤ä¸ªæ“ä½œé‡æ’åºï¼Œå³**happens-beforeå…³ç³»å¹¶ä¸ä»£è¡¨äº†æœ€ç»ˆçš„æ‰§è¡Œé¡ºåº**ã€‚

### as-if-serialä¸happens-beforeçš„åŒºåˆ«

ä¸‹é¢æ¥æ¯”è¾ƒä¸€ä¸‹as-if-serialå’Œhappens-beforeï¼š

> **as-if-serial VS happens-before**

1. as-if-serialè¯­ä¹‰ä¿è¯å•çº¿ç¨‹å†…ç¨‹åºçš„æ‰§è¡Œç»“æœä¸è¢«æ”¹å˜ï¼Œhappens-beforeå…³ç³»ä¿è¯æ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºçš„æ‰§è¡Œç»“æœä¸è¢«æ”¹å˜ã€‚
2. as-if-serialè¯­ä¹‰ç»™ç¼–å†™å•çº¿ç¨‹ç¨‹åºçš„ç¨‹åºå‘˜åˆ›é€ äº†ä¸€ä¸ªå¹»å¢ƒï¼šå•çº¿ç¨‹ç¨‹åºæ˜¯æŒ‰ç¨‹åºçš„é¡ºåºæ¥æ‰§è¡Œçš„ã€‚happens-beforeå…³ç³»ç»™ç¼–å†™æ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºçš„ç¨‹åºå‘˜åˆ›é€ äº†ä¸€ä¸ªå¹»å¢ƒï¼šæ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºæ˜¯æŒ‰happens-beforeæŒ‡å®šçš„é¡ºåºæ¥æ‰§è¡Œçš„ã€‚
3. as-if-serialè¯­ä¹‰å’Œhappens-beforeè¿™ä¹ˆåšçš„ç›®çš„ï¼Œéƒ½æ˜¯ä¸ºäº†åœ¨ä¸æ”¹å˜ç¨‹åºæ‰§è¡Œç»“æœçš„å‰æä¸‹ï¼Œå°½å¯èƒ½åœ°æé«˜ç¨‹åºæ‰§è¡Œçš„å¹¶è¡Œåº¦ã€‚



## è¯·æè¿°ä¸€ä¸‹é”çš„åˆ†ç±»ä»¥åŠJDKä¸­çš„åº”ç”¨ - é˜¿é‡Œ

![img](img/7f749fc8.png)

[ä¸å¯ä¸è¯´çš„Javaâ€œé”â€äº‹ - ç¾å›¢æŠ€æœ¯å›¢é˜Ÿ](https://tech.meituan.com/2018/11/15/java-lock.html)



## æ‰“å¼€åå‘é”æ˜¯å¦æ•ˆç‡ä¸€å®šä¼šæå‡?è‡ªæ—‹é”ä¸€å®šæ¯”é‡é‡çº§é”æ•ˆç‡é«˜å—? - é˜¿é‡Œ

ä¸ä¸€å®šï¼Œåå‘é”å’Œè½»é‡çº§é”/è‡ªæ—‹é”éƒ½æ˜¯ä¸ºç«äº‰ä¸æ¿€çƒˆçš„æƒ…å†µè®¾è®¡çš„ä¼˜åŒ–æ–¹æ¡ˆï¼Œå¦‚æœç«äº‰æ¿€åŠ±ï¼Œé”å‡çº§åè€Œä¼šé™ä½æ€§èƒ½ã€‚

**å¼•å…¥åå‘é”çš„ç›®çš„ï¼š**åœ¨åªæœ‰å•çº¿ç¨‹æ‰§è¡Œæƒ…å†µä¸‹ï¼Œå°½é‡å‡å°‘ä¸å¿…è¦çš„è½»é‡çº§é”æ‰§è¡Œè·¯å¾„ï¼Œè½»é‡çº§é”çš„è·å–åŠé‡Šæ”¾ä¾èµ–å¤šæ¬¡CASåŸå­æŒ‡ä»¤ï¼Œè€Œåå‘é”åªä¾èµ–ä¸€æ¬¡CASåŸå­æŒ‡ä»¤ç½®æ¢ThreadIDï¼Œä¹‹ååªè¦åˆ¤æ–­çº¿ç¨‹IDä¸ºå½“å‰çº¿ç¨‹å³å¯ï¼Œåå‘é”ä½¿ç”¨äº†ä¸€ç§ç­‰åˆ°ç«äº‰å‡ºç°æ‰é‡Šæ”¾é”çš„æœºåˆ¶ï¼Œæ¶ˆé™¤åå‘é”çš„å¼€é”€è¿˜æ˜¯è›®å¤§çš„ã€‚å¦‚æœåŒæ­¥èµ„æºæˆ–ä»£ç ä¸€ç›´éƒ½æ˜¯å¤šçº¿ç¨‹è®¿é—®çš„ï¼Œé‚£ä¹ˆæ¶ˆé™¤åå‘é”è¿™ä¸€æ­¥éª¤å¯¹ä½ æ¥è¯´å°±æ˜¯å¤šä½™çš„ï¼Œå¯ä»¥é€šè¿‡-XX:-UseBiasedLocking=falseæ¥å…³é—­
**å¼•å…¥è½»é‡çº§é”çš„ç›®çš„ï¼š**åœ¨å¤šçº¿ç¨‹äº¤æ›¿æ‰§è¡ŒåŒæ­¥å—çš„æƒ…å†µä¸‹ï¼Œå°½é‡é¿å…é‡é‡çº§é”å¼•èµ·çš„æ€§èƒ½æ¶ˆè€—(ç”¨æˆ·æ€å’Œæ ¸å¿ƒæ€è½¬æ¢)ï¼Œä½†æ˜¯å¦‚æœå¤šä¸ªçº¿ç¨‹åœ¨åŒä¸€æ—¶åˆ»è¿›å…¥ä¸´ç•ŒåŒºï¼Œä¼šå¯¼è‡´è½»é‡çº§é”è†¨èƒ€å‡çº§é‡é‡çº§é”ï¼Œæ‰€ä»¥è½»é‡çº§é”çš„å‡ºç°å¹¶éæ˜¯è¦æ›¿ä»£é‡é‡çº§é”



## ä½ äº†è§£ThreadLocalå—?ä½ çŸ¥é“ThreadLocalä¸­å¦‚ä½•è§£å†³å†…å­˜æ³„æ¼é—®é¢˜å—? - äº¬ä¸œ é˜¿é‡Œ

### 0ã€é—®é¢˜

1. å’ŒSynchronizedçš„åŒºåˆ«
2. å­˜å‚¨åœ¨jvmçš„å“ªä¸ªåŒºåŸŸ
3. çœŸçš„åªæ˜¯å½“å‰çº¿ç¨‹å¯è§å—
4. ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ä¹ˆ
5. ä¸ºä»€ä¹ˆç”¨Entryæ•°ç»„è€Œä¸æ˜¯Entryå¯¹è±¡
6. ä½ å­¦ä¹ çš„å¼€æºæ¡†æ¶å“ªäº›ç”¨åˆ°äº†ThreadLocal
7. ThreadLocalé‡Œçš„å¯¹è±¡ä¸€å®šæ˜¯çº¿ç¨‹å®‰å…¨çš„å—
8. ç¬”è¯•é¢˜

### ä¸€ã€æ¦‚è¿°

#### 1ã€å®˜æ–¹æœ¯è¯­

ThreadLocalç±»æ˜¯ç”¨æ¥æä¾›çº¿ç¨‹å†…éƒ¨çš„å±€éƒ¨å˜é‡ã€‚è®©è¿™äº›å˜é‡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹è®¿é—®ï¼ˆget/setï¼‰æ—¶èƒ½ä¿è¯å„ä¸ªçº¿ç¨‹é‡Œçš„å˜é‡ç›¸å¯¹ç‹¬ç«‹äºå…¶ä»–çº¿ç¨‹å†…çš„å˜é‡ã€‚

#### 2ã€å¤§ç™½è¯

ThreadLocalæ˜¯ä¸€ä¸ªå…³äºåˆ›å»ºçº¿ç¨‹å±€éƒ¨å˜é‡çš„ç±»ã€‚

é€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åˆ›å»ºçš„æˆå‘˜å˜é‡éƒ½æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ã€‚å› ä¸ºä»–å¯èƒ½è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹ï¼Œæ­¤å˜é‡å¯¹äºå¤šä¸ªçº¿ç¨‹ä¹‹é—´å½¼æ­¤å¹¶ä¸ç‹¬ç«‹ï¼Œæ˜¯å…±äº«å˜é‡ã€‚è€Œä½¿ç”¨ThreadLocalåˆ›å»ºçš„å˜é‡åªèƒ½è¢«å½“å‰çº¿ç¨‹è®¿é—®ï¼Œå…¶ä»–çº¿ç¨‹æ— æ³•è®¿é—®å’Œä¿®æ”¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼šå°†çº¿ç¨‹å…¬æœ‰åŒ–å˜æˆçº¿ç¨‹ç§æœ‰åŒ–ã€‚

### äºŒã€åº”ç”¨åœºæ™¯

- æ¯ä¸ªçº¿ç¨‹éƒ½éœ€è¦ä¸€ä¸ªç‹¬äº«çš„å¯¹è±¡ï¼ˆæ¯”å¦‚å·¥å…·ç±»ï¼Œå…¸å‹çš„å°±æ˜¯`SimpleDateFormat`ï¼Œæ¯æ¬¡ä½¿ç”¨éƒ½newä¸€ä¸ªå¤šæµªè´¹æ€§èƒ½å‘€ï¼Œç›´æ¥æ”¾åˆ°æˆå‘˜å˜é‡é‡Œåˆæ˜¯çº¿ç¨‹ä¸å®‰å…¨ï¼Œæ‰€ä»¥æŠŠä»–ç”¨`ThreadLocal`ç®¡ç†èµ·æ¥å°±å®Œç¾äº†ã€‚ï¼‰

æ¯”å¦‚ï¼š

```java
/**
Â * Description: SimpleDateFormatå°±ä¸€ä»½ï¼Œä¸æµªè´¹èµ„æºã€‚
Â *
Â *Â @authorÂ TongWei.ChenÂ 2020-07-10Â 14:00:29
Â */
publicÂ classÂ ThreadLocalTest05Â {
 
Â Â Â Â publicÂ staticÂ StringÂ dateToStr(intÂ millisSeconds)Â {
Â Â Â Â Â Â Â Â DateÂ dateÂ =Â newÂ Date(millisSeconds);
Â Â Â Â Â Â Â Â SimpleDateFormatÂ simpleDateFormatÂ =Â ThreadSafeFormatter.dateFormatThreadLocal.get();
Â Â Â Â Â Â Â Â returnÂ simpleDateFormat.format(date);
Â Â Â Â }
 
Â Â Â Â privateÂ staticÂ finalÂ ExecutorServiceÂ executorServiceÂ =Â Executors.newFixedThreadPool(100);
 
Â Â Â Â publicÂ staticÂ voidÂ main(String[]Â args)Â {
Â Â Â Â Â Â Â Â forÂ (intÂ iÂ =Â 0;Â iÂ <Â 3000;Â i++)Â {
Â Â Â Â Â Â Â Â Â Â Â Â intÂ jÂ =Â i;
Â Â Â Â Â Â Â Â Â Â Â Â executorService.execute(()Â ->Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â StringÂ dateÂ =Â dateToStr(jÂ *Â 1000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â ä»ç»“æœä¸­å¯ä»¥çœ‹å‡ºæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ—¶é—´æ²¡æœ‰é‡å¤çš„ã€‚
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â System.out.println(date);
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â executorService.shutdown();
Â Â Â Â }
}
 
classÂ ThreadSafeFormatterÂ {
Â Â Â Â publicÂ staticÂ ThreadLocal<SimpleDateFormat>Â dateFormatThreadLocalÂ =Â newÂ ThreadLocal()Â {
Â Â Â Â Â Â Â Â @Override
Â Â Â Â Â Â Â Â protectedÂ SimpleDateFormatÂ initialValue()Â {
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ newÂ SimpleDateFormat("yyyy-MM-ddÂ hh:mm:ss");
Â Â Â Â Â Â Â Â }
Â Â Â Â };
 
Â Â Â Â //Â java8çš„å†™æ³•ï¼Œè£…é€¼ç¥å™¨
//Â Â Â Â publicÂ staticÂ ThreadLocal<SimpleDateFormat>Â dateFormatThreadLocalÂ =
//Â Â Â Â Â Â Â Â Â Â Â Â ThreadLocal.withInitial(()Â ->Â newÂ SimpleDateFormat("yyyy-MM-ddÂ hh:mm:ss"));
}
```

> ç»†å¿ƒçš„æœ‹å‹å·²ç»å‘ç°äº†ï¼Œè¿™TMä¹Ÿæ˜¯æ¯ä¸ªçº¿ç¨‹éƒ½åˆ›å»ºä¸€ä¸ª`SimpleDateFormat`å•Šï¼Œè·Ÿç›´æ¥åœ¨æ–¹æ³•å†…éƒ¨newæ²¡åŒºåˆ«ï¼Œé”™äº†ï¼Œå¤§é”™ç‰¹é”™ï¼1ä¸ªè¯·æ±‚è¿›æ¥æ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œä»–å¯èƒ½è´¯ç©¿äº†Nä¸ªæ–¹æ³•ï¼Œä½ è¿™Nä¸ªæ–¹æ³•å‡è®¾æœ‰3ä¸ªéƒ½åœ¨ä½¿ç”¨`dateToStr()`ï¼Œä½ ç›´æ¥newçš„è¯ä¼šäº§ç”Ÿä¸‰ä¸ª`SimpleDateFormat`å¯¹è±¡ï¼Œè€Œç”¨`ThreadLocal`çš„è¯åªä¼šäº§ç”Ÿä¸€ä¸ªå¯¹è±¡ï¼Œä¸€ä¸ªçº¿ç¨‹ä¸€ä¸ªã€‚

- æ¯ä¸ªçº¿ç¨‹å†…éœ€è¦ä¿å­˜å…¨å±€å˜é‡ï¼ˆæ¯”å¦‚åœ¨ç™»å½•æˆåŠŸåå°†ç”¨æˆ·ä¿¡æ¯å­˜åˆ°`ThreadLocal`é‡Œï¼Œç„¶åå½“å‰çº¿ç¨‹æ“ä½œçš„ä¸šåŠ¡é€»è¾‘ç›´æ¥getå–å°±å®Œäº‹äº†ï¼Œæœ‰æ•ˆçš„é¿å…çš„å‚æ•°æ¥å›ä¼ é€’çš„éº»çƒ¦ä¹‹å¤„ï¼‰ï¼Œä¸€å®šå±‚çº§ä¸Šå‡å°‘ä»£ç è€¦åˆåº¦ã€‚

**å†ç»†åŒ–ä¸€ç‚¹å°±æ˜¯ï¼š**

- æ¯”å¦‚å­˜å‚¨ äº¤æ˜“idç­‰ä¿¡æ¯ã€‚æ¯ä¸ªçº¿ç¨‹ç§æœ‰ã€‚
- æ¯”å¦‚aopé‡Œè®°å½•æ—¥å¿—éœ€è¦beforeè®°å½•è¯·æ±‚idï¼Œendæ‹¿å‡ºè¯·æ±‚idï¼Œè¿™ä¹Ÿå¯ä»¥ã€‚
- æ¯”å¦‚jdbcè¿æ¥æ± ï¼ˆå¾ˆå…¸å‹çš„ä¸€ä¸ª`ThreadLocal`ç”¨æ³•ï¼‰
- springæ¡†æ¶çš„äº‹åŠ¡æ§åˆ¶
- ....ç­‰ç­‰....

### ä¸‰ã€æ ¸å¿ƒçŸ¥è¯†

#### 1ã€ç±»å…³ç³»

æ¯ä¸ª`Thread`å¯¹è±¡ä¸­éƒ½æŒæœ‰ä¸€ä¸ª`ThreadLocalMap`çš„æˆå‘˜å˜é‡ã€‚æ¯ä¸ª`ThreadLocalMap`å†…éƒ¨åˆç»´æŠ¤äº†Nä¸ª`Entry`èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯`Entry`æ•°ç»„ï¼Œæ¯ä¸ª`Entry`ä»£è¡¨ä¸€ä¸ªå®Œæ•´çš„å¯¹è±¡ï¼Œkeyæ˜¯`ThreadLocal`æœ¬èº«ï¼Œvalueæ˜¯`ThreadLocal`çš„æ³›å‹å€¼ã€‚

æ ¸å¿ƒæºç å¦‚ä¸‹

```java
// java.lang.Threadç±»é‡ŒæŒæœ‰ThreadLocalMapçš„å¼•ç”¨
public class Thread implements Runnable {
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

// java.lang.ThreadLocalæœ‰å†…éƒ¨é™æ€ç±»ThreadLocalMap
public class ThreadLocal<T> {
    static class ThreadLocalMap {
        private Entry[] table;
        // ThreadLocalMapå†…éƒ¨æœ‰Entryç±»ï¼ŒEntryçš„keyæ˜¯ThreadLocalæœ¬èº«ï¼Œvalueæ˜¯æ³›å‹å€¼
        static class Entry extends WeakReference<ThreadLocal<?>> {
            Object value;
            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
    }
}
```

#### 2ã€ç±»å…³ç³»å›¾

> `ThreadLocal`å†…å­˜ç»“æ„å›¾ã€‚

![img](img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9lUVB5QmZmWWJ1ZjlBRVc2UlNWaWJUbEhFV1JGQWtsT05PQ0g3TGg0aWJDbGZCRnp3MWduOExuZUVkY2RSNGplQnA4NWRneHlXSkU0eG42RXhGTU9pYkdQdy82NDA)

#### 3ã€ä¸»è¦æ–¹æ³•

- `initialValue`ï¼šåˆå§‹åŒ–ã€‚åœ¨`get`æ–¹æ³•é‡Œæ‡’åŠ è½½çš„ã€‚
- `get`ï¼šå¾—åˆ°è¿™ä¸ªçº¿ç¨‹å¯¹åº”çš„valueã€‚*å¦‚æœè°ƒç”¨getä¹‹å‰æ²¡setè¿‡ï¼Œåˆ™getå†…éƒ¨ä¼šæ‰§è¡Œ`initialValue`æ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ã€‚*
- `set`ï¼šä¸ºè¿™ä¸ªçº¿ç¨‹è®¾ç½®ä¸€ä¸ªæ–°å€¼ã€‚
- `remove`ï¼šåˆ é™¤è¿™ä¸ªçº¿ç¨‹å¯¹åº”çš„å€¼ï¼Œé˜²æ­¢å†…å­˜æ³„éœ²çš„æœ€ä½³æ‰‹æ®µã€‚

##### 3.1ã€`initialValue`

###### 3.1.1ã€ä»€ä¹ˆæ„æ€

è§åçŸ¥æ„ï¼Œåˆå§‹åŒ–ä¸€äº›valueï¼ˆæ³›å‹å€¼ï¼‰ã€‚æ‡’åŠ è½½çš„ã€‚

###### 3.1.2ã€è§¦å‘æ—¶æœº

è°ƒç”¨`get`æ–¹æ³•ä¹‹å‰æ²¡æœ‰è°ƒç”¨`set`æ–¹æ³•ï¼Œåˆ™`get`æ–¹æ³•å†…éƒ¨ä¼šè§¦å‘`initialValue`ï¼Œä¹Ÿå°±æ˜¯è¯´`get`çš„æ—¶å€™å¦‚æœæ²¡æ‹¿åˆ°ä¸œè¥¿ï¼Œåˆ™ä¼šè§¦å‘`initialValue`ã€‚

###### 3.1.3ã€è¡¥å……è¯´æ˜

- é€šå¸¸ï¼Œæ¯ä¸ªçº¿ç¨‹æœ€å¤šè°ƒç”¨ä¸€æ¬¡æ­¤æ–¹æ³•ã€‚ä½†æ˜¯å¦‚æœå·²ç»è°ƒç”¨äº†`remove()`ï¼Œç„¶åå†æ¬¡è°ƒç”¨`get()`çš„è¯ï¼Œåˆ™å¯ä»¥å†æ¬¡è§¦å‘`initialValue`ã€‚
- å¦‚æœè¦é‡å†™çš„è¯ä¸€èˆ¬å»ºè®®é‡‡å–åŒ¿åå†…éƒ¨ç±»çš„æ–¹å¼é‡å†™æ­¤æ–¹æ³•ï¼Œå¦åˆ™é»˜è®¤è¿”å›çš„æ˜¯nullã€‚

> æ¯”å¦‚ï¼š

```java
public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal() {
    @Override
    protected SimpleDateFormat initialValue() {
        return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
    }
};

// Java8çš„é«˜é€¼æ ¼å†™æ³•
public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal =
            ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"));
```

###### 3.1.4ã€æºç 

```java
// ç”±å­ç±»æä¾›å®ç°ã€‚
// protectedçš„å«ä¹‰å°±æ˜¯äº¤ç»™å­ç±»å¹²çš„ã€‚
protected T initialValue() {
    return null;
}
```

##### 3.2ã€`get`

###### 3.2.1ã€ä»€ä¹ˆæ„æ€

è·å–å½“å‰çº¿ç¨‹ä¸‹çš„ThreadLocalä¸­çš„å€¼ã€‚

###### 3.2.2ã€æºç 

```java
/**
 * è·å–å½“å‰çº¿ç¨‹ä¸‹çš„entryé‡Œçš„valueå€¼ã€‚
 * å…ˆè·å–å½“å‰çº¿ç¨‹ä¸‹çš„ThreadLocalMapï¼Œ
 * ç„¶åä»¥å½“å‰ThreadLocalä¸ºkeyå–å‡ºmapä¸­çš„value
 */
public T get() {
    // è·å–å½“å‰çº¿ç¨‹
    Thread t = Thread.currentThread();
    // è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„ThreadLocalMapå¯¹è±¡ã€‚
    ThreadLocalMap map = getMap(t);
    // è‹¥è·å–åˆ°äº†ã€‚åˆ™è·å–æ­¤ThreadLocalMapä¸‹çš„entryå¯¹è±¡ï¼Œè‹¥entryä¹Ÿè·å–åˆ°äº†ï¼Œé‚£ä¹ˆç›´æ¥è·å–entryå¯¹åº”çš„valueè¿”å›å³å¯ã€‚
    if (map != null) {
        // è·å–æ­¤ThreadLocalMapä¸‹çš„entryå¯¹è±¡
        ThreadLocalMap.Entry e = map.getEntry(this);
        // è‹¥entryä¹Ÿè·å–åˆ°äº†
        if (e != null) {
            @SuppressWarnings("unchecked")
            // ç›´æ¥è·å–entryå¯¹åº”çš„valueè¿”å›ã€‚
            T result = (T)e.value;
            return result;
        }
    }
    // è‹¥æ²¡è·å–åˆ°ThreadLocalMapæˆ–æ²¡è·å–åˆ°Entryï¼Œåˆ™è®¾ç½®åˆå§‹å€¼ã€‚
    // çŸ¥è¯†ç‚¹ï¼šæˆ‘æ—©å°±è¯´äº†ï¼Œåˆå§‹å€¼æ–¹æ³•æ˜¯å»¶è¿ŸåŠ è½½ï¼Œåªæœ‰åœ¨getæ‰ä¼šç”¨åˆ°ï¼Œè¿™ä¸‹çœ‹åˆ°äº†å§ï¼Œåªæœ‰åœ¨è¿™è·å–æ²¡è·å–åˆ°æ‰ä¼šåˆå§‹åŒ–ï¼Œä¸‹æ¬¡å°±è‚¯å®šæœ‰å€¼äº†ï¼Œæ‰€ä»¥åªä¼šæ‰§è¡Œä¸€æ¬¡ï¼ï¼ï¼
    return setInitialValue();
}
```

###### 3.3ã€`set`

###### 3.3.1ã€ä»€ä¹ˆæ„æ€

å…¶å®å¹²çš„äº‹å’Œ`initialValue`æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯setå€¼ï¼Œåªæ˜¯è°ƒç”¨æ—¶æœºä¸åŒã€‚setæ˜¯æƒ³ç”¨å°±ç”¨ï¼Œapiæ‘†åœ¨è¿™é‡Œï¼Œä½ æƒ³ç”¨å°±è°ƒä¸€ä¸‹setæ–¹æ³•ã€‚å¾ˆè‡ªç”±ã€‚

###### 3.3.2ã€æºç 

```java
/**
 * è®¾ç½®å½“å‰çº¿ç¨‹çš„çº¿ç¨‹å±€éƒ¨å˜é‡çš„å€¼
 * å®é™…ä¸ŠThreadLocalçš„å€¼æ˜¯æ”¾å…¥äº†å½“å‰çº¿ç¨‹çš„ä¸€ä¸ªThreadLocalMapå®ä¾‹ä¸­ï¼Œæ‰€ä»¥åªèƒ½åœ¨æœ¬çº¿ç¨‹ä¸­è®¿é—®ã€‚
 */
public void set(T value) {
    // è·å–å½“å‰çº¿ç¨‹
    Thread t = Thread.currentThread();
    // è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„ThreadLocalMapå®ä¾‹ï¼Œæ³¨æ„è¿™é‡Œæ˜¯å°†tä¼ è¿›å»äº†ï¼Œtæ˜¯å½“å‰çº¿ç¨‹ï¼Œå°±æ˜¯è¯´ThreadLocalMapæ˜¯åœ¨çº¿ç¨‹é‡ŒæŒæœ‰çš„å¼•ç”¨ã€‚
    ThreadLocalMap map = getMap(t);
    // è‹¥å½“å‰çº¿ç¨‹æœ‰å¯¹åº”çš„ThreadLocalMapå®ä¾‹ï¼Œåˆ™å°†å½“å‰ThreadLocalå¯¹è±¡ä½œä¸ºkeyï¼Œvalueåšä¸ºå€¼å­˜åˆ°ThreadLocalMapçš„entryé‡Œã€‚
    if (map != null)
        map.set(this, value);
    else
        // è‹¥å½“å‰çº¿ç¨‹æ²¡æœ‰å¯¹åº”çš„ThreadLocalMapå®ä¾‹ï¼Œåˆ™åˆ›å»ºThreadLocalMapï¼Œå¹¶å°†æ­¤çº¿ç¨‹ä¸ä¹‹ç»‘å®š
        createMap(t, value);
}
```

##### 3.4ã€`remove`

###### 3.4.1ã€ä»€ä¹ˆæ„æ€

å°†å½“å‰çº¿ç¨‹ä¸‹çš„ThreadLocalçš„å€¼åˆ é™¤ï¼Œç›®çš„æ˜¯ä¸ºäº†å‡å°‘å†…å­˜å ç”¨ã€‚ä¸»è¦ç›®çš„æ˜¯é˜²æ­¢å†…å­˜æ³„æ¼ã€‚å†…å­˜æ³„æ¼é—®é¢˜ä¸‹é¢ä¼šè¯´ã€‚

###### 3.4.2ã€æºç 

```java
/**
 * å°†å½“å‰çº¿ç¨‹å±€éƒ¨å˜é‡çš„å€¼åˆ é™¤ï¼Œç›®çš„æ˜¯ä¸ºäº†å‡å°‘å†…å­˜å ç”¨ã€‚ä¸»è¦ç›®çš„æ˜¯é˜²æ­¢å†…å­˜æ³„æ¼ã€‚å†…å­˜æ³„æ¼é—®é¢˜ä¸‹é¢ä¼šè¯´ã€‚
 */
public void remove() {
    // è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalMapå¯¹è±¡ï¼Œå¹¶å°†å…¶ç§»é™¤ã€‚
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        // ç›´æ¥ç§»é™¤ä»¥å½“å‰ThreadLocalä¸ºkeyçš„value
        m.remove(this);
}
```

#### 4ã€ThreadLocalMap

ä¸ºå•¥å•ç‹¬æ‹¿å‡ºæ¥è¯´ä¸‹ï¼Œæˆ‘å°±æ˜¯æƒ³å¼ºè°ƒä¸€ç‚¹ï¼šè¿™ä¸ªä¸œè¥¿æ˜¯å½’`Thread`ç±»æ‰€æœ‰çš„ã€‚å®ƒçš„å¼•ç”¨åœ¨`Thread`ç±»é‡Œï¼Œè¿™ä¹Ÿè¯å®äº†ä¸€ä¸ªé—®é¢˜ï¼š`ThreadLocalMap`ç±»å†…éƒ¨ä¸ºä»€ä¹ˆæœ‰`Entry`æ•°ç»„ï¼Œè€Œä¸æ˜¯`Entry`å¯¹è±¡ï¼Ÿ

å› ä¸ºä½ ä¸šåŠ¡ä»£ç èƒ½newå¥½å¤šä¸ª`ThreadLocal`å¯¹è±¡ï¼Œå„å¸å…¶èŒã€‚ä½†æ˜¯åœ¨ä¸€æ¬¡è¯·æ±‚é‡Œï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹é‡Œï¼Œ`ThreadLocalMap`æ˜¯åŒä¸€ä¸ªï¼Œè€Œä¸æ˜¯å¤šä¸ªï¼Œä¸ç®¡ä½ newå‡ æ¬¡`ThreadLocal`ï¼Œ`ThreadLocalMap`åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œå°±ä¸€ä¸ªï¼Œå› ä¸ºå†è¯´ä¸€æ¬¡ï¼Œ`ThreadLocalMap`çš„å¼•ç”¨æ˜¯åœ¨`Thread`é‡Œçš„ï¼Œæ‰€ä»¥å®ƒé‡Œé¢çš„`Entry`æ•°ç»„å­˜æ”¾çš„æ˜¯ä¸€ä¸ªçº¿ç¨‹é‡Œä½ newå‡ºæ¥çš„å¤šä¸ª`ThreadLocal`å¯¹è±¡ã€‚

æ ¸å¿ƒæºç å¦‚ä¸‹ï¼š

```java
// åœ¨ä½ è°ƒç”¨ThreadLocal.get()æ–¹æ³•çš„æ—¶å€™å°±ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œå®ƒçš„è¿”å›æ˜¯å½“å‰çº¿ç¨‹é‡Œçš„threadLocalsçš„å¼•ç”¨ã€‚
// è¿™ä¸ªå¼•ç”¨æŒ‡å‘çš„æ˜¯ThreadLocalé‡Œçš„ThreadLocalMapå¯¹è±¡
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

public class Thread implements Runnable {
    // ThreadLocal.ThreadLocalMap
    ThreadLocal.ThreadLocalMap threadLocals = null;
}
```

### å››ã€å®Œæ•´æºç 

#### 1ã€æ ¸å¿ƒæºç 

```java
// æœ¬åœ°çº¿ç¨‹ã€‚Threadï¼šçº¿ç¨‹ã€‚Localï¼šæœ¬åœ°
public class ThreadLocal<T> {
	// æ„é€ å™¨
	public ThreadLocal() {}
    
    // åˆå§‹å€¼ï¼Œç”¨æ¥åˆå§‹åŒ–å€¼ç”¨çš„ï¼Œæ¯”å¦‚ï¼šThreadLocal<Integer> count = new ThreadLocal<>();
    // ä½ æƒ³Integer value = count.get(); value++;è¿™æ ·æ˜¯æŠ¥é”™çš„ï¼Œå› ä¸ºcountç°åœ¨è¿˜æ²¡å€¼ï¼Œå–å‡ºæ¥çš„æ˜¯ä¸ªnull,æ‰€ä»¥ä½ éœ€è¦å…ˆé‡å†™æ­¤æ–¹æ³•ä¸ºvalueèµ‹ä¸Šåˆå§‹å€¼ï¼Œæœ¬èº«æ–¹æ³•æ˜¯protectedä¹Ÿä»£è¡¨å°±æ˜¯ä¸ºäº†å­ç±»é‡å†™çš„ã€‚
    // æ­¤æ–¹æ³•æ˜¯ä¸€ä¸ªå»¶è¿Ÿè°ƒç”¨æ–¹æ³•ï¼Œåœ¨çº¿ç¨‹ç¬¬ä¸€æ¬¡è°ƒç”¨getçš„æ—¶å€™æ‰æ‰§è¡Œï¼Œä¸‹é¢å…·ä½“åˆ†ææºç å°±çŸ¥é“äº†ã€‚
	protected T initialValue() {}
   
    // åˆ›å»ºThreadLocalMapï¼ŒThreadLocalåº•å±‚å…¶å®å°±æ˜¯ä¸€ä¸ªmapæ¥ç»´æŠ¤çš„ã€‚
	void createMap(Thread t, T firstValue) {}
    
    // è¿”å›è¯¥å½“å‰çº¿ç¨‹å¯¹åº”çš„çº¿ç¨‹å±€éƒ¨å˜é‡å€¼ã€‚
	public T get() {}

    // è·å–ThreadLocalMap
	ThreadLocalMap getMap(Thread t) {}

    // è®¾ç½®å½“å‰çº¿ç¨‹çš„çº¿ç¨‹å±€éƒ¨å˜é‡çš„å€¼
	public void set(T value) {}

    // å°†å½“å‰çº¿ç¨‹å±€éƒ¨å˜é‡çš„å€¼åˆ é™¤ï¼Œç›®çš„æ˜¯ä¸ºäº†å‡å°‘å†…å­˜å ç”¨ã€‚å…¶å®å½“çº¿ç¨‹ç»“æŸåå¯¹åº”è¯¥çº¿ç¨‹çš„å±€éƒ¨å˜é‡å°†è‡ªåŠ¨è¢«åƒåœ¾å›æ”¶ï¼Œæ‰€ä»¥æ— éœ€æˆ‘ä»¬è°ƒç”¨removeï¼Œæˆ‘ä»¬è°ƒç”¨removeæ— éä¹Ÿå°±æ˜¯åŠ å¿«å†…å­˜å›æ”¶é€Ÿåº¦ã€‚
	public void remove() {}
    
    // è®¾ç½®åˆå§‹å€¼ï¼Œè°ƒç”¨initialValue
	private T setInitialValue() {}
    
    // é™æ€å†…éƒ¨ç±»ï¼Œä¸€ä¸ªmapæ¥ç»´æŠ¤çš„ï¼ï¼ï¼
    static class ThreadLocalMap {
        // ThreadLocalMapçš„é™æ€å†…éƒ¨ç±»ï¼Œç»§æ‰¿äº†å¼±å¼•ç”¨ï¼Œè¿™æ­£æ˜¯ä¸ä¼šé€ æˆå†…å­˜æ³„æ¼æ ¹æœ¬åŸå› 
        // Entryçš„keyä¸ºThreadLocalå¹¶ä¸”æ˜¯å¼±å¼•ç”¨ã€‚valueæ˜¯å€¼
        static class Entry extends WeakReference<ThreadLocal<?>> {}
    }
}
```

#### 2ã€set()

```java
/**
 * è®¾ç½®å½“å‰çº¿ç¨‹çš„çº¿ç¨‹å±€éƒ¨å˜é‡çš„å€¼
 * å®é™…ä¸ŠThreadLocalçš„å€¼æ˜¯æ”¾å…¥äº†å½“å‰çº¿ç¨‹çš„ä¸€ä¸ªThreadLocalMapå®ä¾‹ä¸­ï¼Œæ‰€ä»¥åªèƒ½åœ¨æœ¬çº¿ç¨‹ä¸­è®¿é—®ã€‚
 */
public void set(T value) {
    // è·å–å½“å‰çº¿ç¨‹
    Thread t = Thread.currentThread();
    // è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„ThreadLocalMapå®ä¾‹
    ThreadLocalMap map = getMap(t);
    // è‹¥å½“å‰çº¿ç¨‹æœ‰å¯¹åº”çš„ThreadLocalMapå®ä¾‹ï¼Œåˆ™å°†å½“å‰ThreadLocalå¯¹è±¡ä½œä¸ºkeyï¼Œvalueåšä¸ºå€¼å­˜åˆ°ThreadLocalMapçš„entryé‡Œã€‚
    if (map != null)
        map.set(this, value);
    else
        // è‹¥å½“å‰çº¿ç¨‹æ²¡æœ‰å¯¹åº”çš„ThreadLocalMapå®ä¾‹ï¼Œåˆ™åˆ›å»ºThreadLocalMapï¼Œå¹¶å°†æ­¤çº¿ç¨‹ä¸ä¹‹ç»‘å®š
        createMap(t, value);
}
```

#### 3ã€getMap()

```java
// åœ¨ä½ è°ƒç”¨ThreadLocal.get()æ–¹æ³•çš„æ—¶å€™å°±ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œå®ƒçš„è¿”å›æ˜¯å½“å‰çº¿ç¨‹é‡Œçš„threadLocalsçš„å¼•ç”¨ã€‚
// è¿™ä¸ªå¼•ç”¨æŒ‡å‘çš„æ˜¯ThreadLocalé‡Œçš„ThreadLocalMapå¯¹è±¡
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

public class Thread implements Runnable {
    // ThreadLocal.ThreadLocalMap
    ThreadLocal.ThreadLocalMap threadLocals = null;
}
```

#### 4ã€map.set()

```java
// ä¸å¤šBBï¼Œå°±å’ŒHashMapçš„setä¸€ä¸ªé“ç†ï¼Œåªæ˜¯èµ‹å€¼key,valueã€‚
// éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œkeyæ˜¯ThreadLocalå¯¹è±¡ï¼Œvalueæ˜¯å€¼
private void set(ThreadLocal<?> key, Object value) {}
```

#### 5ã€createMap()

```java
/**
 * åˆ›å»ºThreadLocalMapå¯¹è±¡ã€‚
 * t.threadLocalsåœ¨ä¸Šé¢çš„getMapä¸­è¯¦ç»†ä»‹ç»äº†ã€‚æ­¤å¤„ä¸BBã€‚
 * å®ä¾‹åŒ–ThreadLocalMapå¹¶ä¸”ä¼ å…¥ä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªæ˜¯å½“å‰ThreadLocalå¯¹è±¡ä¸€ä¸ªæ˜¯valueã€‚
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

// ThreadLocalMapæ„é€ å™¨ã€‚
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    // é‡ç‚¹çœ‹è¿™é‡Œï¼ï¼ï¼ï¼ï¼ï¼
    // newäº†ä¸€ä¸ªThreadLocalMapçš„å†…éƒ¨ç±»Entryï¼Œä¸”å°†keyå’Œvalueä¼ å…¥ã€‚
    // keyæ˜¯ThreadLocalå¯¹è±¡ã€‚
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}

/**
 * åˆ°è¿™é‡Œæœ‹å‹ä»¬åº”è¯¥çœŸç›¸å¤§ç™½äº†ï¼Œå…¶å®ThreadLocalå°±æ˜¯å†…éƒ¨ç»´æŠ¤ä¸€ä¸ªThreadLocalMapï¼Œ
 * è€ŒThreadLocalMapå†…éƒ¨åˆç»´æŠ¤äº†ä¸€ä¸ªEntryå¯¹è±¡ã€‚Entryå¯¹è±¡æ˜¯key-valueå½¢å¼ï¼Œ
 * keyæ˜¯ThreadLocalå¯¹è±¡ï¼Œvalueæ˜¯ä¼ å…¥çš„value
 * æ‰€ä»¥æˆ‘ä»¬å¯¹ThreadLocalçš„æ“ä½œå…¶å®éƒ½æ˜¯å¯¹å†…éƒ¨çš„ThreadLocalMap.Entryçš„æ“ä½œ
 * æ‰€ä»¥ä¿è¯äº†çº¿ç¨‹ä¹‹å‰äº’ä¸å¹²æ‰°ã€‚
 */
```

#### 6ã€get()

```java
/**
 * è·å–å½“å‰çº¿ç¨‹ä¸‹çš„entryé‡Œçš„valueå€¼ã€‚
 * å…ˆè·å–å½“å‰çº¿ç¨‹ä¸‹çš„ThreadLocalMapï¼Œ
 * ç„¶åä»¥å½“å‰ThreadLocalä¸ºkeyå–å‡ºmapä¸­çš„value
 */
public T get() {
    // è·å–å½“å‰çº¿ç¨‹
    Thread t = Thread.currentThread();
    // è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„ThreadLocalMapå¯¹è±¡ã€‚
    ThreadLocalMap map = getMap(t);
    // è‹¥è·å–åˆ°äº†ã€‚åˆ™è·å–æ­¤ThreadLocalMapä¸‹çš„entryå¯¹è±¡ï¼Œè‹¥entryä¹Ÿè·å–åˆ°äº†ï¼Œé‚£ä¹ˆç›´æ¥è·å–entryå¯¹åº”çš„valueè¿”å›å³å¯ã€‚
    if (map != null) {
        // è·å–æ­¤ThreadLocalMapä¸‹çš„entryå¯¹è±¡
        ThreadLocalMap.Entry e = map.getEntry(this);
        // è‹¥entryä¹Ÿè·å–åˆ°äº†
        if (e != null) {
            @SuppressWarnings("unchecked")
            // ç›´æ¥è·å–entryå¯¹åº”çš„valueè¿”å›ã€‚
            T result = (T)e.value;
            return result;
        }
    }
    // è‹¥æ²¡è·å–åˆ°ThreadLocalMapæˆ–æ²¡è·å–åˆ°Entryï¼Œåˆ™è®¾ç½®åˆå§‹å€¼ã€‚
    // çŸ¥è¯†ç‚¹ï¼šæˆ‘æ—©å°±è¯´äº†ï¼Œåˆå§‹å€¼æ–¹æ³•æ˜¯å»¶è¿ŸåŠ è½½ï¼Œåªæœ‰åœ¨getæ‰ä¼šç”¨åˆ°ï¼Œè¿™ä¸‹çœ‹åˆ°äº†å§ï¼Œåªæœ‰åœ¨è¿™è·å–æ²¡è·å–åˆ°æ‰ä¼šåˆå§‹åŒ–ï¼Œä¸‹æ¬¡å°±è‚¯å®šæœ‰å€¼äº†ï¼Œæ‰€ä»¥åªä¼šæ‰§è¡Œä¸€æ¬¡ï¼ï¼ï¼
    return setInitialValue();
}
```

#### 7ã€setInitialValue()

```java
// è®¾ç½®åˆå§‹å€¼
private T setInitialValue() {
    // è°ƒç”¨åˆå§‹å€¼æ–¹æ³•ï¼Œç”±å­ç±»æä¾›ã€‚
    T value = initialValue();
    // è·å–å½“å‰çº¿ç¨‹
    Thread t = Thread.currentThread();
    // è·å–map
    ThreadLocalMap map = getMap(t);
    // è·å–åˆ°äº†
    if (map != null)
        // set
        map.set(this, value);
    else
        // æ²¡è·å–åˆ°ã€‚åˆ›å»ºmapå¹¶èµ‹å€¼
        createMap(t, value);
    // è¿”å›åˆå§‹å€¼ã€‚
    return value;
}
```

#### 8ã€initialValue()

```java
// ç”±å­ç±»æä¾›å®ç°ã€‚
// protected
protected T initialValue() {
    return null;
}
```

#### 9ã€remove()

```java
/**
 * å°†å½“å‰çº¿ç¨‹å±€éƒ¨å˜é‡çš„å€¼åˆ é™¤ï¼Œç›®çš„æ˜¯ä¸ºäº†å‡å°‘å†…å­˜å ç”¨ã€‚
 * å…¶å®å½“çº¿ç¨‹ç»“æŸåå¯¹åº”è¯¥çº¿ç¨‹çš„å±€éƒ¨å˜é‡å°†è‡ªåŠ¨è¢«åƒåœ¾å›æ”¶ï¼Œæ‰€ä»¥æ— éœ€æˆ‘ä»¬è°ƒç”¨removeï¼Œæˆ‘ä»¬è°ƒç”¨removeæ— éä¹Ÿå°±æ˜¯åŠ å¿«å†…å­˜å›æ”¶é€Ÿåº¦ã€‚
 */
public void remove() {
    // è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalMapå¯¹è±¡ï¼Œå¹¶å°†å…¶ç§»é™¤ã€‚
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
```

#### 10ã€å°ç»“

åªè¦æ‹æ¸…æ¥šå¦‚ä¸‹å‡ ä¸ªç±»çš„å…³ç³»ï¼Œ`ThreadLocal`å°†å˜å¾—so easyï¼

```
Thread`ã€`ThreadLocal`ã€`ThreadLocalMap`ã€`Entry
```

ä¸€å¥è¯æ€»ç»“å°±æ˜¯ï¼š`Thread`ç»´æŠ¤äº†`ThreadLocalMap`ï¼Œè€Œ`ThreadLocalMap`é‡Œç»´æŠ¤äº†`Entry`ï¼Œè€Œ`Entry`é‡Œå­˜çš„æ˜¯ä»¥`ThreadLocal`ä¸ºkeyï¼Œä¼ å…¥çš„å€¼ä¸ºvalueçš„é”®å€¼å¯¹ã€‚

### äº”ã€ç­”ç–‘ï¼ˆé¢è¯•é¢˜ï¼‰

#### 1ã€å’ŒSynchronizedçš„åŒºåˆ«

é—®ï¼šä»–å’Œçº¿ç¨‹åŒæ­¥æœºåˆ¶ï¼ˆå¦‚ï¼šSynchronizedï¼‰æä¾›ä¸€æ ·çš„åŠŸèƒ½ï¼Œè¿™ä¸ªå¾ˆåŠå•Šã€‚

ç­”ï¼šæ”¾å±ï¼åŒæ­¥æœºåˆ¶ä¿è¯çš„æ˜¯å¤šçº¿ç¨‹åŒæ—¶æ“ä½œå…±äº«å˜é‡å¹¶ä¸”èƒ½æ­£ç¡®çš„è¾“å‡ºç»“æœã€‚ThreadLocalä¸è¡Œå•Šï¼Œä»–æŠŠå…±äº«å˜é‡å˜æˆçº¿ç¨‹ç§æœ‰äº†ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ç‹¬ç«‹çš„ä¸€ä¸ªå˜é‡ã€‚ä¸¾ä¸ªé€šä¿—æ˜“æ‡‚çš„æ¡ˆä¾‹ï¼šç½‘ç«™è®¡æ•°å™¨ï¼Œä½ ç»™å˜é‡count++çš„æ—¶å€™å¸¦ä¸Šsynchronizedå³å¯è§£å†³ã€‚ThreadLocalçš„è¯åšä¸åˆ°å•Šï¼Œä»–æ²¡å‘ç»Ÿè®¡ï¼Œä»–åªèƒ½è¯´èƒ½ç»Ÿè®¡æ¯ä¸ªçº¿ç¨‹ç™»å½•äº†å¤šå°‘æ¬¡ã€‚

#### 2ã€å­˜å‚¨åœ¨jvmçš„å“ªä¸ªåŒºåŸŸ

é—®ï¼šçº¿ç¨‹ç§æœ‰ï¼Œé‚£ä¹ˆå°±æ˜¯è¯´ThreadLocalçš„å®ä¾‹å’Œä»–çš„å€¼æ˜¯æ”¾åˆ°æ ˆä¸Šå’¯ï¼Ÿ

ç­”ï¼šä¸æ˜¯ã€‚è¿˜æ˜¯åœ¨å †çš„ã€‚ThreadLocalå¯¹è±¡ä¹Ÿæ˜¯å¯¹è±¡ï¼Œå¯¹è±¡å°±åœ¨å †ã€‚åªæ˜¯JVMé€šè¿‡ä¸€äº›æŠ€å·§å°†å…¶å¯è§æ€§å˜æˆäº†çº¿ç¨‹å¯è§ã€‚

#### 3ã€çœŸçš„åªæ˜¯å½“å‰çº¿ç¨‹å¯è§å—

é—®ï¼šçœŸçš„åªæ˜¯å½“å‰çº¿ç¨‹å¯è§å—ï¼Ÿ

ç­”ï¼šè²Œä¼¼ä¸æ˜¯ï¼Œè²Œä¼¼é€šè¿‡`InheritableThreadLocal`ç±»å¯ä»¥å®ç°å¤šä¸ªçº¿ç¨‹è®¿é—®`ThreadLocal`çš„å€¼ï¼Œä½†æ˜¯æˆ‘æ²¡ç ”ç©¶è¿‡ï¼ŒçŸ¥é“è¿™ç äº‹å°±è¡Œäº†ã€‚

#### 4ã€ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ä¹ˆ

é—®ï¼šä¼šå¯¼è‡´å†…å­˜æ³„æ¼ä¹ˆï¼Ÿ

ç­”ï¼šåˆ†æä¸€ä¸‹ï¼š

- 1ã€`ThreadLocalMap.Entry`çš„keyä¼šå†…å­˜æ³„æ¼å—ï¼Ÿ
- 2ã€`ThreadLocalMap.Entry`çš„valueä¼šå†…å­˜æ³„æ¼å—ï¼Ÿ

å…ˆçœ‹ä¸‹key-valueçš„æ ¸å¿ƒæºç 

```java
staticÂ classÂ EntryÂ extendsÂ WeakReference<ThreadLocal<?>>Â {
Â Â Â Â ObjectÂ value;
Â Â Â Â Entry(ThreadLocal<?>Â k,Â ObjectÂ v)Â {
Â Â Â Â Â Â Â Â super(k);
Â Â Â Â Â Â Â Â valueÂ =Â v;
Â Â Â Â }
}
```

å…ˆçœ‹ç»§æ‰¿å…³ç³»ï¼Œå‘ç°æ˜¯ç»§æ‰¿äº†å¼±å¼•ç”¨ï¼Œè€Œä¸”keyç›´æ¥æ˜¯äº¤ç»™äº†çˆ¶ç±»å¤„ç†`super(key)`ï¼Œçˆ¶ç±»æ˜¯ä¸ªå¼±å¼•ç”¨ï¼Œæ‰€ä»¥keyå®Œå…¨ä¸å­˜åœ¨å†…å­˜æ³„æ¼é—®é¢˜ï¼Œå› ä¸ºä»–ä¸æ˜¯å¼ºå¼•ç”¨ï¼Œå®ƒå¯ä»¥è¢«GCå›æ”¶çš„ã€‚

> å¼±å¼•ç”¨çš„ç‰¹ç‚¹ï¼šå¦‚æœè¿™ä¸ªå¯¹è±¡åªè¢«å¼±å¼•ç”¨å…³è”ï¼Œæ²¡æœ‰ä»»ä½•å¼ºå¼•ç”¨å…³è”ï¼Œé‚£ä¹ˆè¿™ä¸ªå¯¹è±¡å°±å¯ä»¥è¢«GCå›æ”¶æ‰ã€‚å¼±å¼•ç”¨ä¸ä¼šé˜»æ­¢GCå›æ”¶ã€‚è¿™æ˜¯jvmçŸ¥è¯†ã€‚

å†çœ‹valueï¼Œå‘ç°valueæ˜¯ä¸ªå¼ºå¼•ç”¨ï¼Œä½†æ˜¯æƒ³äº†ä¸‹ä¹Ÿæ²¡é—®é¢˜çš„å‘€ï¼Œå› ä¸ºçº¿ç¨‹ç»ˆæ­¢äº†ï¼Œæˆ‘ç®¡ä½ å¼ºå¼•ç”¨è¿˜æ˜¯å¼±å¼•ç”¨ï¼Œéƒ½ä¼šè¢«GCæ‰çš„ï¼Œå› ä¸ºå¼•ç”¨é“¾æ–­äº†ï¼ˆjvmç”¨çš„å¯è¾¾æ€§åˆ†ææ³•ï¼Œçº¿ç¨‹ç»ˆæ­¢äº†ï¼Œæ ¹èŠ‚ç‚¹å°±æ–­äº†ï¼Œä¸‹é¢çš„éƒ½ä¼šè¢«å›æ”¶ï¼‰ã€‚

è¿™ä¹ˆåˆ†æä¸€ç‚¹æ¯›ç—…éƒ½æ²¡æœ‰ï¼Œä½†æ˜¯å¿˜äº†ä¸€ä¸ªä¸»è¦çš„è§’è‰²ï¼Œé‚£å°±æ˜¯**çº¿ç¨‹æ± **ï¼Œçº¿ç¨‹æ± çš„å­˜åœ¨æ ¸å¿ƒçº¿ç¨‹æ˜¯ä¸ä¼šé”€æ¯çš„ï¼Œåªè¦åˆ›å»ºå‡ºæ¥ä»–ä¼šåå¤åˆ©ç”¨ï¼Œç”Ÿå‘½å‘¨æœŸä¸ä¼šç»“æŸæ‰ï¼Œä½†æ˜¯keyæ˜¯å¼±å¼•ç”¨ä¼šè¢«GCå›æ”¶æ‰ï¼Œvalueå¼ºå¼•ç”¨ä¸ä¼šå›æ”¶ï¼Œæ‰€ä»¥å½¢æˆäº†å¦‚ä¸‹åœºé¢ï¼š

```
Thread->ThreadLocalMap->Entry(keyä¸ºnull)->value
```

ç”±äºvalueå’ŒThreadè¿˜å­˜åœ¨é“¾è·¯å…³ç³»ï¼Œè¿˜æ˜¯å¯è¾¾çš„ï¼Œæ‰€ä»¥ä¸ä¼šè¢«å›æ”¶ï¼Œè¿™æ ·è¶Šæ¥è¶Šå¤šçš„åƒåœ¾å¯¹è±¡äº§ç”Ÿå´æ— æ³•å›æ”¶ï¼Œæ—©æ™¨å†…å­˜æ³„æ¼ï¼Œæ—¶é—´ä¹…äº†å¿…å®šOOMã€‚

è§£å†³æ–¹æ¡ˆ`ThreadLocal`å·²ç»ä¸ºæˆ‘ä»¬æƒ³å¥½äº†ï¼Œæä¾›äº†`remove()`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯å°†valueç§»å‡ºå»çš„ã€‚æ‰€ä»¥ç”¨å®Œåè®°å¾—`remove()`ã€‚

#### 5ã€ä¸ºä»€ä¹ˆç”¨Entryæ•°ç»„è€Œä¸æ˜¯Entryå¯¹è±¡

> è¿™ä¸ªå…¶å®ä¸»è¦æƒ³è€ƒ`ThreadLocalMap`æ˜¯åœ¨`Thread`é‡ŒæŒæœ‰çš„å¼•ç”¨ã€‚

é—®ï¼š`ThreadLocalMap`å†…éƒ¨çš„tableä¸ºä»€ä¹ˆæ˜¯æ•°ç»„è€Œä¸æ˜¯å•ä¸ªå¯¹è±¡å‘¢ï¼Ÿ

ç­”ï¼šå› ä¸ºä½ ä¸šåŠ¡ä»£ç èƒ½newå¥½å¤šä¸ª`ThreadLocal`å¯¹è±¡ï¼Œå„å¸å…¶èŒã€‚ä½†æ˜¯åœ¨ä¸€æ¬¡è¯·æ±‚é‡Œï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹é‡Œï¼Œ`ThreadLocalMap`æ˜¯åŒä¸€ä¸ªï¼Œè€Œä¸æ˜¯å¤šä¸ªï¼Œä¸ç®¡ä½ newå‡ æ¬¡`ThreadLocal`ï¼Œ`ThreadLocalMap`åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œå°±ä¸€ä¸ªï¼Œå› ä¸º`ThreadLocalMap`çš„å¼•ç”¨æ˜¯åœ¨`Thread`é‡Œçš„ï¼Œæ‰€ä»¥å®ƒé‡Œé¢çš„`Entry`æ•°ç»„å­˜æ”¾çš„æ˜¯ä¸€ä¸ªçº¿ç¨‹é‡Œä½ newå‡ºæ¥çš„å¤šä¸ª`ThreadLocal`å¯¹è±¡ã€‚

#### 6ã€ä½ å­¦ä¹ çš„å¼€æºæ¡†æ¶å“ªäº›ç”¨åˆ°äº†ThreadLocal

Springæ¡†æ¶ã€‚

DateTimeContextHolder
RequestContextHolder

#### 7ã€ThreadLocalé‡Œçš„å¯¹è±¡ä¸€å®šæ˜¯çº¿ç¨‹å®‰å…¨çš„å—

æœªå¿…ï¼Œå¦‚æœåœ¨æ¯ä¸ªçº¿ç¨‹ä¸­`ThreadLocal.set()`è¿›å»çš„ä¸œè¥¿æœ¬æ¥å°±æ˜¯å¤šçº¿ç¨‹å…±äº«çš„åŒä¸€ä¸ªå¯¹è±¡ï¼Œæ¯”å¦‚staticå¯¹è±¡ï¼Œé‚£ä¹ˆå¤šä¸ªçº¿ç¨‹çš„`ThreadLocal.get()`è·å–çš„è¿˜æ˜¯è¿™ä¸ªå…±äº«å¯¹è±¡æœ¬èº«ï¼Œè¿˜æ˜¯æœ‰å¹¶å‘è®¿é—®çº¿ç¨‹ä¸å®‰å…¨é—®é¢˜ã€‚

#### 8ã€ç¬”è¯•é¢˜

é—®ï¼šä¸‹é¢è¿™æ®µç¨‹åºä¼šè¾“å‡ºä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

```java
public class TestThreadLocalNpe {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal();

    public static void set() {
        threadLocal.set(1L);
    }

    public static long get() {
        return threadLocal.get();
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            set();
            System.out.println(get());
        }).start();
        // ç›®çš„å°±æ˜¯ä¸ºäº†è®©å­çº¿ç¨‹å…ˆè¿è¡Œå®Œ
        Thread.sleep(100);
        System.out.println(get());
    }
}
```

ç­”ï¼š

```java
1
Exception in thread "main" java.lang.NullPointerException
 at com.chentongwei.study.thread.TestThreadLocalNpe.get(TestThreadLocalNpe.java:16)
 at com.chentongwei.study.thread.TestThreadLocalNpe.main(TestThreadLocalNpe.java:26)
```

ä¸ºä»€ä¹ˆï¼Ÿ

ä¸ºä»€ä¹ˆè¾“å‡ºä¸ª1ï¼Œç„¶åç©ºæŒ‡é’ˆäº†ï¼Ÿ

é¦–å…ˆè¾“å‡º1æ˜¯æ²¡ä»»ä½•é—®é¢˜çš„ï¼Œå…¶æ¬¡ä¸»çº¿ç¨‹ç©ºæŒ‡é’ˆæ˜¯ä¸ºä»€ä¹ˆï¼Ÿ

å¦‚æœä½ è¿™é‡Œå›ç­”

```java
1
1
```

é‚£æˆ‘æ­å–œä½ ï¼Œä½ è¿`ThreadLocal`éƒ½ä¸çŸ¥é“æ˜¯å•¥ï¼Œè¿™æ˜æ˜¾ä¸¤ä¸ªçº¿ç¨‹ï¼Œå­çº¿ç¨‹å’Œä¸»çº¿ç¨‹ã€‚å­çº¿ç¨‹è®¾ç½®1ï¼Œä¸»çº¿ç¨‹è‚¯å®šæ‹¿ä¸åˆ°å•Šï¼Œ`ThreadLocal`å’Œçº¿ç¨‹æ˜¯å˜»å˜»ç›¸å…³çš„ã€‚è¿™ä¸ªä¸å¤šè´¹å£èˆŒã€‚

è¯´è¯´ä¸ºä»€ä¹ˆæ˜¯ç©ºæŒ‡é’ˆï¼Ÿ

å› ä¸ºä½ getæ–¹æ³•ç”¨çš„longè€Œä¸æ˜¯Longï¼Œé‚£ä¹Ÿåº”è¯¥è¿”å›nullå•Šï¼Œå¤§å“¥ï¼Œlongæ˜¯åŸºæœ¬ç±»å‹ï¼Œé»˜è®¤å€¼æ˜¯0ï¼Œæ²¡æœ‰nullè¿™ä¸€è¯´æ³•ã€‚`ThreadLocal`é‡Œçš„æ³›å‹æ˜¯Longï¼Œgetå´æ˜¯åŸºæœ¬ç±»å‹ï¼Œè¿™éœ€è¦æ‹†ç®±æ“ä½œçš„ï¼Œä¹Ÿå°±æ˜¯ä¼šæ‰§è¡Œ`null.longValue()`çš„æ“ä½œï¼Œè¿™ç»é€¼ç©ºæŒ‡é’ˆäº†ã€‚

> çœ‹ä¼¼ä¸€é“Javaseçš„åŸºç¡€é¢˜ç›®ï¼Œå®åˆ™éšè—äº†å¾ˆå¤šçŸ¥è¯†ã€‚

### å…­ã€ThreadLocalå·¥å…·ç±»

```java
packageÂ com.duoku.base.util;
 
importÂ com.google.common.collect.Maps;
importÂ org.springframework.core.NamedThreadLocal;
 
importÂ java.util.Map;
 
/**
Â *Â Description:
Â *
Â *Â @authorÂ TongWei.ChenÂ 2019-09-09Â 18:35:30
Â */
publicÂ classÂ ThreadLocalUtilÂ {
 
Â Â Â Â privateÂ staticÂ finalÂ ThreadLocal<Map<String,Â Object>>Â threadLocalÂ =Â newÂ NamedThreadLocal("xxx-threadlocal")Â {
Â Â Â Â Â Â Â Â @Override
Â Â Â Â Â Â Â Â protectedÂ Map<String,Â Object>Â initialValue()Â {
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ Maps.newHashMap();
Â Â Â Â Â Â Â Â }
Â Â Â Â };
 
Â Â Â Â publicÂ staticÂ Map<String,Â Object>Â getThreadLocal(){
Â Â Â Â Â Â Â Â returnÂ threadLocal.get();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â publicÂ staticÂ <T>Â TÂ get(StringÂ key)Â {
Â Â Â Â Â Â Â Â MapÂ mapÂ =Â threadLocal.get();
Â Â Â Â Â Â Â Â //Â todo:copyÂ aÂ newÂ one
Â Â Â Â Â Â Â Â returnÂ (T)map.get(key);
Â Â Â Â }
 
Â Â Â Â publicÂ staticÂ <T>Â TÂ get(StringÂ key,TÂ defaultValue)Â {
Â Â Â Â Â Â Â Â MapÂ mapÂ =Â threadLocal.get();
Â Â Â Â Â Â Â Â returnÂ (T)map.get(key)Â ==Â nullÂ ?Â defaultValueÂ :Â (T)map.get(key);
Â Â Â Â }
 
Â Â Â Â publicÂ staticÂ voidÂ set(StringÂ key,Â ObjectÂ value)Â {
Â Â Â Â Â Â Â Â MapÂ mapÂ =Â threadLocal.get();
Â Â Â Â Â Â Â Â map.put(key,Â value);
Â Â Â Â }
 
Â Â Â Â publicÂ staticÂ voidÂ set(Map<String,Â Object>Â keyValueMap)Â {
Â Â Â Â Â Â Â Â MapÂ mapÂ =Â threadLocal.get();
Â Â Â Â Â Â Â Â map.putAll(keyValueMap);
Â Â Â Â }
 
Â Â Â Â publicÂ staticÂ voidÂ remove()Â {
Â Â Â Â Â Â Â Â threadLocal.remove();
Â Â Â Â }
 
}
```